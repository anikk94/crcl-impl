/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package crcl.ui.forcetorquesensorsimulator;

import crcl.base.CRCLStatusType;
import crcl.base.ConfigureStatusReportType;
import crcl.base.ForceTorqueSensorStatusType;
import crcl.base.GetStatusType;
import crcl.base.PointType;
import crcl.base.PoseStatusType;
import crcl.base.PoseType;
import crcl.base.SensorStatusesType;
import crcl.ui.PoseDisplay;
import crcl.ui.PoseDisplayMode;
import crcl.utils.CRCLCopier;
import crcl.utils.CRCLException;
import crcl.utils.CRCLSocket;
import crcl.utils.XFuture;
import crcl.utils.XFutureVoid;
import crcl.utils.server.CRCLServerClientState;
import crcl.utils.server.CRCLServerSocket;
import crcl.utils.server.CRCLServerSocketEvent;
import crcl.utils.server.CRCLServerSocketEventListener;
import crcl.utils.server.CRCLServerSocketStateGenerator;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.PrintStream;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.Function;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JFileChooser;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.TableModel;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVParser;
import org.apache.commons.csv.CSVPrinter;
import org.apache.commons.csv.CSVRecord;
import org.checkerframework.checker.guieffect.qual.UIEffect;
import org.checkerframework.checker.nullness.qual.Nullable;

/**
 *
 * @author Will Shackleford {@literal <william.shackleford@nist.gov>}
 */
public class ForceTorqueSimJPanel extends javax.swing.JPanel {

    /**
     * Creates new form ForceTorqueSimJPanel
     */
    @SuppressWarnings("initialization")
    public ForceTorqueSimJPanel() {
        statusOut = new CRCLStatusType();
        statusOut.setSensorStatuses(new SensorStatusesType());
        sensorStatus = new ForceTorqueSensorStatusType();
        statusOut.getSensorStatuses().getForceTorqueSensorStatus().add(sensorStatus);
        initComponents();
        PoseDisplay.updateDisplayMode(jTablePose, PoseDisplayMode.XYZ_RPY, false);
        PoseDisplay.updateDisplayMode(jTablePoseForceOut, PoseDisplayMode.XYZ_RPY, false);
        updateSensorStatus();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings({"unchecked", "rawtypes", "nullness"})
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jMenu1 = new javax.swing.JMenu();
        jMenu2 = new javax.swing.JMenu();
        jTabbedPane1 = new javax.swing.JTabbedPane();
        jPanelCommunications = new javax.swing.JPanel();
        jPanelCrclSensorServerOut = new javax.swing.JPanel();
        jCheckBoxStartSensorOutServer = new javax.swing.JCheckBox();
        jTextFieldCRCLSensorOutPort = new javax.swing.JTextField();
        jLabel1 = new javax.swing.JLabel();
        jPanelCRCLPositionIn = new javax.swing.JPanel();
        jLabel3 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        jTextFieldPoseCRCLHost = new javax.swing.JTextField();
        jCheckBoxEnablePoseInConnection = new javax.swing.JCheckBox();
        jTextFieldPoseCRCLPort = new javax.swing.JTextField();
        jButton1 = new javax.swing.JButton();
        jPanel1 = new javax.swing.JPanel();
        jTablePose = new javax.swing.JTable();
        jPanelForceOut = new javax.swing.JPanel();
        jTablePoseForceOut = new javax.swing.JTable();
        jPanelOffsets = new javax.swing.JPanel();
        valueJPanelFx = new crcl.ui.forcetorquesensorsimulator.ValueJPanel();
        valueJPanelFy = new crcl.ui.forcetorquesensorsimulator.ValueJPanel();
        valueJPanelFz = new crcl.ui.forcetorquesensorsimulator.ValueJPanel();
        valueJPanelTx = new crcl.ui.forcetorquesensorsimulator.ValueJPanel();
        valueJPanelTy = new crcl.ui.forcetorquesensorsimulator.ValueJPanel();
        valueJPanelTz = new crcl.ui.forcetorquesensorsimulator.ValueJPanel();
        jPanel2 = new javax.swing.JPanel();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTableObjects = new javax.swing.JTable();
        jTextFieldObjectsFile = new javax.swing.JTextField();
        jButtonSaveObjectsFile = new javax.swing.JButton();
        jButtonOpenObjectsFile = new javax.swing.JButton();
        jButtonAddObject = new javax.swing.JButton();
        jButtonDeleteObject = new javax.swing.JButton();

        jMenu1.setText("File");
        jMenuBar1.add(jMenu1);

        jMenu2.setText("Edit");
        jMenuBar1.add(jMenu2);

        jPanelCrclSensorServerOut.setBorder(javax.swing.BorderFactory.createTitledBorder("CRCL Sensor Out Server"));

        jCheckBoxStartSensorOutServer.setText("Start");
        jCheckBoxStartSensorOutServer.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckBoxStartSensorOutServerActionPerformed(evt);
            }
        });

        jTextFieldCRCLSensorOutPort.setText("8888");

        jLabel1.setText("Port: ");

        javax.swing.GroupLayout jPanelCrclSensorServerOutLayout = new javax.swing.GroupLayout(jPanelCrclSensorServerOut);
        jPanelCrclSensorServerOut.setLayout(jPanelCrclSensorServerOutLayout);
        jPanelCrclSensorServerOutLayout.setHorizontalGroup(
            jPanelCrclSensorServerOutLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanelCrclSensorServerOutLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanelCrclSensorServerOutLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanelCrclSensorServerOutLayout.createSequentialGroup()
                        .addComponent(jLabel1)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jTextFieldCRCLSensorOutPort))
                    .addGroup(jPanelCrclSensorServerOutLayout.createSequentialGroup()
                        .addComponent(jCheckBoxStartSensorOutServer)
                        .addGap(0, 0, Short.MAX_VALUE)))
                .addContainerGap())
        );
        jPanelCrclSensorServerOutLayout.setVerticalGroup(
            jPanelCrclSensorServerOutLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanelCrclSensorServerOutLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanelCrclSensorServerOutLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel1)
                    .addComponent(jTextFieldCRCLSensorOutPort, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jCheckBoxStartSensorOutServer)
                .addContainerGap())
        );

        jPanelCRCLPositionIn.setBorder(javax.swing.BorderFactory.createTitledBorder("CRCL Pose In Connection"));

        jLabel3.setText("Host: ");

        jLabel2.setText("Port: ");

        jTextFieldPoseCRCLHost.setText("localhost");

        jCheckBoxEnablePoseInConnection.setText("Enable");
        jCheckBoxEnablePoseInConnection.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckBoxEnablePoseInConnectionActionPerformed(evt);
            }
        });

        jTextFieldPoseCRCLPort.setText("64444");

        jButton1.setText("Update Pose");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanelCRCLPositionInLayout = new javax.swing.GroupLayout(jPanelCRCLPositionIn);
        jPanelCRCLPositionIn.setLayout(jPanelCRCLPositionInLayout);
        jPanelCRCLPositionInLayout.setHorizontalGroup(
            jPanelCRCLPositionInLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanelCRCLPositionInLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanelCRCLPositionInLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanelCRCLPositionInLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                        .addGroup(jPanelCRCLPositionInLayout.createSequentialGroup()
                            .addComponent(jLabel3)
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                            .addComponent(jTextFieldPoseCRCLHost))
                        .addGroup(jPanelCRCLPositionInLayout.createSequentialGroup()
                            .addComponent(jLabel2)
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                            .addComponent(jTextFieldPoseCRCLPort, javax.swing.GroupLayout.PREFERRED_SIZE, 601, javax.swing.GroupLayout.PREFERRED_SIZE)))
                    .addGroup(jPanelCRCLPositionInLayout.createSequentialGroup()
                        .addComponent(jCheckBoxEnablePoseInConnection)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jButton1)))
                .addContainerGap())
        );
        jPanelCRCLPositionInLayout.setVerticalGroup(
            jPanelCRCLPositionInLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanelCRCLPositionInLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanelCRCLPositionInLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel2)
                    .addComponent(jTextFieldPoseCRCLPort, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanelCRCLPositionInLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel3)
                    .addComponent(jTextFieldPoseCRCLHost, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(jPanelCRCLPositionInLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jCheckBoxEnablePoseInConnection)
                    .addComponent(jButton1))
                .addContainerGap())
        );

        jPanel1.setBorder(javax.swing.BorderFactory.createTitledBorder("Pose In"));

        jTablePose.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {"X", null},
                {"Y", null},
                {"Z", null},
                {"XI", null},
                {"XJ", null},
                {"XK", null},
                {"ZI", null},
                {"ZJ", null},
                {"Zk", null}
            },
            new String [] {
                "Pose Axis", "Position"
            }
        ) {
            Class[] types = new Class [] {
                java.lang.String.class, java.lang.Double.class
            };
            boolean[] canEdit = new boolean [] {
                false, false
            };

            public Class getColumnClass(int columnIndex) {
                return types [columnIndex];
            }

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jTablePose, javax.swing.GroupLayout.PREFERRED_SIZE, 162, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jTablePose, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );

        jPanelForceOut.setBorder(javax.swing.BorderFactory.createTitledBorder("Force  Torque Out"));

        jTablePoseForceOut.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {"X", null},
                {"Y", null},
                {"Z", null},
                {"XI", null},
                {"XJ", null},
                {"XK", null},
                {"ZI", null},
                {"ZJ", null},
                {"Zk", null}
            },
            new String [] {
                "Pose Axis", "Position"
            }
        ) {
            Class[] types = new Class [] {
                java.lang.String.class, java.lang.Double.class
            };
            boolean[] canEdit = new boolean [] {
                false, false
            };

            public Class getColumnClass(int columnIndex) {
                return types [columnIndex];
            }

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });

        javax.swing.GroupLayout jPanelForceOutLayout = new javax.swing.GroupLayout(jPanelForceOut);
        jPanelForceOut.setLayout(jPanelForceOutLayout);
        jPanelForceOutLayout.setHorizontalGroup(
            jPanelForceOutLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanelForceOutLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jTablePoseForceOut, javax.swing.GroupLayout.PREFERRED_SIZE, 162, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );
        jPanelForceOutLayout.setVerticalGroup(
            jPanelForceOutLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanelForceOutLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jTablePoseForceOut, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );

        javax.swing.GroupLayout jPanelCommunicationsLayout = new javax.swing.GroupLayout(jPanelCommunications);
        jPanelCommunications.setLayout(jPanelCommunicationsLayout);
        jPanelCommunicationsLayout.setHorizontalGroup(
            jPanelCommunicationsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanelCommunicationsLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanelCommunicationsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jPanelCrclSensorServerOut, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addGroup(jPanelCommunicationsLayout.createSequentialGroup()
                        .addGroup(jPanelCommunicationsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jPanelCRCLPositionIn, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addGroup(jPanelCommunicationsLayout.createSequentialGroup()
                                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(jPanelForceOut, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
                        .addGap(0, 0, Short.MAX_VALUE)))
                .addContainerGap())
        );
        jPanelCommunicationsLayout.setVerticalGroup(
            jPanelCommunicationsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanelCommunicationsLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jPanelCrclSensorServerOut, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jPanelCRCLPositionIn, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addGroup(jPanelCommunicationsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jPanelForceOut, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(107, Short.MAX_VALUE))
        );

        jTabbedPane1.addTab("Communications", jPanelCommunications);

        valueJPanelFx.setName("Fx"); // NOI18N

        valueJPanelFy.setName("Fy"); // NOI18N

        valueJPanelFz.setName("Fz"); // NOI18N

        valueJPanelTx.setName("Tx"); // NOI18N

        valueJPanelTy.setName("Ty"); // NOI18N

        valueJPanelTz.setName("Tz"); // NOI18N

        javax.swing.GroupLayout jPanelOffsetsLayout = new javax.swing.GroupLayout(jPanelOffsets);
        jPanelOffsets.setLayout(jPanelOffsetsLayout);
        jPanelOffsetsLayout.setHorizontalGroup(
            jPanelOffsetsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanelOffsetsLayout.createSequentialGroup()
                .addGap(12, 12, 12)
                .addGroup(jPanelOffsetsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(valueJPanelFx, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(valueJPanelTz, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(valueJPanelFy, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(valueJPanelTx, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(valueJPanelFz, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(valueJPanelTy, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        jPanelOffsetsLayout.setVerticalGroup(
            jPanelOffsetsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanelOffsetsLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(valueJPanelFx, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(valueJPanelFy, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(valueJPanelFz, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(valueJPanelTx, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(valueJPanelTy, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(valueJPanelTz, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(176, Short.MAX_VALUE))
        );

        jTabbedPane1.addTab("Offset: ", jPanelOffsets);

        jTableObjects.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {
                "Name", "X_Min", "Y_Min", "Z_Min", "X_Maxl", "Y_Max", "Z_Max", "X_Scale", "Y_Scale", "Z_Scale"
            }
        ) {
            Class[] types = new Class [] {
                java.lang.String.class, java.lang.Double.class, java.lang.Double.class, java.lang.Double.class, java.lang.Double.class, java.lang.Double.class, java.lang.Double.class, java.lang.Double.class, java.lang.Double.class, java.lang.Double.class
            };

            public Class getColumnClass(int columnIndex) {
                return types [columnIndex];
            }
        });
        jScrollPane1.setViewportView(jTableObjects);

        jButtonSaveObjectsFile.setText("Save");
        jButtonSaveObjectsFile.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonSaveObjectsFileActionPerformed(evt);
            }
        });

        jButtonOpenObjectsFile.setText("Open");
        jButtonOpenObjectsFile.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonOpenObjectsFileActionPerformed(evt);
            }
        });

        jButtonAddObject.setText("Add");
        jButtonAddObject.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonAddObjectActionPerformed(evt);
            }
        });

        jButtonDeleteObject.setText("Delete");
        jButtonDeleteObject.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonDeleteObjectActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 676, Short.MAX_VALUE)
                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, jPanel2Layout.createSequentialGroup()
                        .addComponent(jTextFieldObjectsFile)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jButtonOpenObjectsFile)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jButtonSaveObjectsFile))
                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, jPanel2Layout.createSequentialGroup()
                        .addComponent(jButtonAddObject)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jButtonDeleteObject)
                        .addGap(0, 0, Short.MAX_VALUE)))
                .addContainerGap())
        );
        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jTextFieldObjectsFile, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jButtonSaveObjectsFile)
                    .addComponent(jButtonOpenObjectsFile))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 516, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jButtonAddObject)
                    .addComponent(jButtonDeleteObject))
                .addContainerGap())
        );

        jTabbedPane1.addTab("Objects", jPanel2);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jTabbedPane1)
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jTabbedPane1)
                .addContainerGap())
        );
    }// </editor-fold>//GEN-END:initComponents

    private void jCheckBoxStartSensorOutServerActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckBoxStartSensorOutServerActionPerformed
        boolean doStart = jCheckBoxStartSensorOutServer.isSelected();
        try {
            if (doStart) {
                startServer();
            } else if (null != crclServerSocket) {
                crclServerSocket.close();
            }
        } catch (Exception ex) {
            LOGGER.log(Level.SEVERE, "connect=" + doStart, ex);
        }
    }//GEN-LAST:event_jCheckBoxStartSensorOutServerActionPerformed

    private volatile @Nullable
    CRCLSocket poseInConnection = null;
    private volatile @Nullable
    CRCLStatusType poseStatus = null;
    private volatile javax.swing.@Nullable Timer timer = null;

    @UIEffect
    private void jCheckBoxEnablePoseInConnectionActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckBoxEnablePoseInConnectionActionPerformed
        if (jCheckBoxEnablePoseInConnection.isSelected()) {
            startPoseInConnection();
        } else {
            stopPoseInConnection();
        }
    }//GEN-LAST:event_jCheckBoxEnablePoseInConnectionActionPerformed

    private void stopPoseInConnection() {
        try {
            if (null != poseInConnection) {
                poseInConnection.close();
                poseInConnection = null;
            }
            if (null != timer) {
                timer.stop();
                timer = null;
            }
        } catch (IOException ex) {
            java.util.logging.Logger.getLogger(ForceTorqueSimJPanel.class.getName()).log(Level.SEVERE, null, ex);
        }
    }

    private void startPoseInConnection() throws NumberFormatException {
        try {
            CRCLSocket newConnection = new CRCLSocket(jTextFieldPoseCRCLHost.getText(), Integer.parseInt(jTextFieldPoseCRCLPort.getText().trim()));
            ConfigureStatusReportType confStatus = new ConfigureStatusReportType();
            confStatus.setReportPoseStatus(true);
            newConnection.writeCommand(confStatus);
            poseInConnection = newConnection;
            timer = new javax.swing.Timer(50, e -> {
                getAndUpdatePose();
            });
            timer.start();
        } catch (CRCLException | IOException ex) {
            java.util.logging.Logger.getLogger(ForceTorqueSimJPanel.class.getName()).log(Level.SEVERE, null, ex);
        }
    }

    @SuppressWarnings("nullness")
    private XFutureVoid getAndUpdatePose() {
        XFuture<@Nullable PoseType> poseFuture
                = getPoseFuture();
        return poseFuture
                .thenAccept((PoseType pose) -> {
                    updateDisplayAndStatusWithPose(pose);
                });
    }

    private void updateDisplayAndStatusWithPose(@Nullable PoseType pose) {
        if (null != pose) {
            javax.swing.SwingUtilities.invokeLater(() -> PoseDisplay.updatePoseTable(pose, jTablePose, PoseDisplayMode.XYZ_RPY));
            updateSensorStatusWithPose(pose);
        }
    }

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        getPose();
    }//GEN-LAST:event_jButton1ActionPerformed

    private void jButtonAddObjectActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonAddObjectActionPerformed
        DefaultTableModel dtm = (DefaultTableModel) jTableObjects.getModel();
        dtm.addRow(new Object[]{"object" + dtm.getRowCount(), -100.0, -100.0, -100.0, 100.0, 100.0, 100.0, 0.0, 0.0, 1000.0});
    }//GEN-LAST:event_jButtonAddObjectActionPerformed

    private void jButtonDeleteObjectActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonDeleteObjectActionPerformed
        final int selectedRow = jTableObjects.getSelectedRow();
        if (selectedRow < 0 || selectedRow > jTableObjects.getRowCount()) {
            return;
        }
        DefaultTableModel dtm = (DefaultTableModel) jTableObjects.getModel();
        dtm.removeRow(selectedRow);
    }//GEN-LAST:event_jButtonDeleteObjectActionPerformed

    private void jButtonOpenObjectsFileActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonOpenObjectsFileActionPerformed
        JFileChooser chooser = new JFileChooser();
        String text = jTextFieldObjectsFile.getText();
        if (text != null && text.length() > 0) {
            File f = new File(text);
            File parent = f.getParentFile();
            if (null != parent) {
                chooser.setCurrentDirectory(parent);
            }
        }
        if (chooser.showOpenDialog(this) == JFileChooser.APPROVE_OPTION) {
            final File selectedFile = chooser.getSelectedFile();
            loadObjectsFile(selectedFile);
        }
    }//GEN-LAST:event_jButtonOpenObjectsFileActionPerformed

    private void jButtonSaveObjectsFileActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonSaveObjectsFileActionPerformed
        JFileChooser chooser = new JFileChooser();
        String text = jTextFieldObjectsFile.getText();
        if (text != null && text.length() > 0) {
            File f = new File(text);
            File parent = f.getParentFile();
            if (null != parent) {
                chooser.setCurrentDirectory(parent);
            }
        }
        if (chooser.showSaveDialog(this) == JFileChooser.APPROVE_OPTION) {
            final File selectedFile = chooser.getSelectedFile();
            saveObjectsFile(selectedFile);
        }
    }//GEN-LAST:event_jButtonSaveObjectsFileActionPerformed

    private void loadObjectsFile(final File selectedFile) {
        try {
            jTextFieldObjectsFile.setText(selectedFile.getCanonicalPath());
            readCsvFileToTableAndMap(false, (DefaultTableModel) jTableObjects.getModel(), selectedFile, null, null, null);
        } catch (Exception ex) {
            LOGGER.log(Level.SEVERE, "selectedFile=" + selectedFile, ex);
        }
    }

    private void saveObjectsFile(final File selectedFile) {
        try {
            jTextFieldObjectsFile.setText(selectedFile.getCanonicalPath());
            saveTableModel(selectedFile, (DefaultTableModel) jTableObjects.getModel());
        } catch (Exception ex) {
            LOGGER.log(Level.SEVERE, "selectedFile=" + selectedFile, ex);
        }
    }

    private static String[] tableHeaders(TableModel tm) {
        String headers[] = new String[tm.getColumnCount()];
        for (int i = 0; i < tm.getColumnCount() && i < headers.length; i++) {
            headers[i] = tm.getColumnName(i);
        }
        return headers;
    }

    private static void saveTableModel(File f, TableModel tm) throws IOException {
        try (CSVPrinter printer = new CSVPrinter(new PrintStream(new FileOutputStream(f)), CSVFormat.DEFAULT.withHeader(tableHeaders(tm)))) {

            List<String> colNameList = new ArrayList<>();
            for (int i = 0; i < tm.getColumnCount(); i++) {
                colNameList.add(tm.getColumnName(i));
            }
            for (int i = 0; i < tm.getRowCount(); i++) {
                List<Object> l = new ArrayList<>();
                for (int j = 0; j < tm.getColumnCount(); j++) {
                    Object o = tm.getValueAt(i, j);
                    if (o == null) {
                        l.add("");
                    }
                    if (o instanceof File) {
                        File parentFile = f.getParentFile();
                        if (null != parentFile) {
                            Path rel = parentFile.toPath().toRealPath().relativize(Paths.get(((File) o).getCanonicalPath())).normalize();
                            if (rel.toString().length() < ((File) o).getCanonicalPath().length()) {
                                l.add(rel);
                            } else {
                                l.add(o);
                            }
                        } else {
                            l.add(o);
                        }
                    } else {
                        l.add(o);
                    }
                }
                printer.printRecord(l);
            }
        }
    }

    public String getObjectsFileName() {
        return jTextFieldObjectsFile.getText();
    }

    public void setObjectsFileName(String name) {
        if (name == null || name.trim().length() < 1) {
            jTextFieldObjectsFile.setText("");
            return;
        }
        loadObjectsFile(new File(name));
    }

    @UIEffect
    public static <T> void readCsvFileToTableAndMap(
            boolean forceColumns,
            @Nullable DefaultTableModel dtm,
            File f,
            @Nullable String nameRecord,
            @Nullable Map<String, T> map,
            @Nullable Function<CSVRecord, T> recordToValue) {

        if (null != dtm) {
            dtm.setRowCount(0);
        }
        try (CSVParser parser = new CSVParser(new FileReader(f), CSVFormat.DEFAULT.withFirstRecordAsHeader())) {
            Map<String, Integer> headerMap = parser.getHeaderMap();
            if (forceColumns && null != dtm) {
                dtm.setRowCount(0);
                dtm.setColumnCount(0);
                for (String key : headerMap.keySet()) {
                    dtm.addColumn(key);
                }
            }
            List<CSVRecord> records = parser.getRecords();
            int skipRows = 0;
            if (null != dtm) {
                for (CSVRecord rec : records) {
                    String colName = dtm.getColumnName(0);
                    Integer colIndex = headerMap.get(colName);
                    if (colIndex == null) {
                        throw new IllegalArgumentException(f + " does not have field " + colName);
                    }
                    String val0 = rec.get(colIndex);
                    if (!val0.equals(colName) && val0.length() > 0) {
                        break;
                    }
                    if (val0.length() < 1) {
                        LOGGER.log(Level.WARNING, "skipping record with empty name field : rec=" + rec + " in file=" + f.getCanonicalPath() + ", colName=" + colName + ", val0=" + val0 + ",skipRows=" + skipRows);
                    }
                    skipRows++;
                }
                dtm.setRowCount(records.size() - skipRows);
            }
            ROW_LOOP:
            for (int i = skipRows; i < records.size(); i++) {
                CSVRecord rec = records.get(i);
                if (null != dtm) {
                    for (int j = 0; j < dtm.getColumnCount(); j++) {
                        String colName = dtm.getColumnName(j);
                        Integer colIndex = headerMap.get(colName);
                        if (colIndex == null) {
                            continue ROW_LOOP;
                        }
                        String val = rec.get(colIndex);
                        try {
                            if (null != val) {
                                if (val.equals(colName) || (j == 0 && val.length() < 1)) {
                                    continue ROW_LOOP;
                                }
                                Class<?> colClass = dtm.getColumnClass(j);
                                if (colClass == Double.class) {
                                    dtm.setValueAt(Double.valueOf(val), i - skipRows, j);
                                } else if (colClass == Boolean.class) {
                                    dtm.setValueAt(Boolean.valueOf(val), i - skipRows, j);
                                } else {
                                    dtm.setValueAt(val, i - skipRows, j);
                                }
                            }
                        } catch (Exception exception) {
                            String msg = "colName=" + colName + ", colIndex=" + colIndex + ", val=" + val + ", rec=" + rec;
                            LOGGER.log(Level.SEVERE, msg, exception);
                            throw new RuntimeException(msg, exception);
                        }
                    }
                }
                try {
                    if (null != nameRecord && null != map && null != recordToValue) {
                        String name = rec.get(nameRecord);
                        T value = recordToValue.apply(rec);
                        map.put(name, value);
                    }
                } catch (Exception exception) {
                    LOGGER.log(Level.SEVERE, "rec=" + rec, exception);
                    throw new RuntimeException(exception);
                }
            }
        } catch (Exception ex) {
            LOGGER.log(Level.SEVERE,
                    "forceColumns=" + forceColumns
                    + ", dtm=" + dtm
                    + ", f=" + f
                    + ", nameRecord=" + nameRecord
                    + ", map=" + map
                    + ", recordToValue=" + recordToValue,
                    ex
            );
            throw new RuntimeException(ex);
        }
    }

    private static final Logger LOGGER = Logger.getLogger(ForceTorqueSimJPanel.class.getName());

    public int getCRCLSensorOutPort() {
        if (crclServerSocket != null) {
            return crclServerSocket.getPort();
        } else {
            return Integer.parseInt(jTextFieldCRCLSensorOutPort.getText());
        }
    }

    public void setCRCLSensorOutPort(int port) {
        if (crclServerSocket != null && crclServerSocket.getPort() != port) {
            crclServerSocket.close();
            crclServerSocket = null;
            jTextFieldCRCLSensorOutPort.setText(Integer.toString(port));
            try {
                startServer(port);
            } catch (IOException ex) {
                java.util.logging.Logger.getLogger(ForceTorqueSimJPanel.class.getName()).log(Level.SEVERE, null, ex);
            }
        } else {
            jTextFieldCRCLSensorOutPort.setText(Integer.toString(port));
        }
    }

    public int getPoseCRCLPort() {
        if (poseInConnection != null) {
            return poseInConnection.getPort();
        }
        return Integer.parseInt(jTextFieldPoseCRCLPort.getText());
    }

    public void setPoseCRCLPort(int port) {
        if (poseInConnection != null && port != poseInConnection.getPort()) {
            stopPoseInConnection();
            jTextFieldPoseCRCLPort.setText(Integer.toString(port));
            if (null != getPoseServiceThread) {
                getPoseServiceThread.setName(tcount.incrementAndGet() + "ForceTorqueSimGetPose" + port);
            }
            startPoseInConnection();
        } else {
            jTextFieldPoseCRCLPort.setText(Integer.toString(port));
        }
    }

    public String getPoseCRCLHost() {
        return jTextFieldPoseCRCLHost.getText();
    }

    public void setPoseCRCLHost(String host) {
        jTextFieldPoseCRCLHost.setText(host);
    }

    private final AtomicInteger getPoseCount = new AtomicInteger();

    private @Nullable
    PoseType getPose() {
        final CRCLSocket poseInConnectionStackCopy = poseInConnection;
        if (null != poseInConnectionStackCopy) {
            try {
                final GetStatusType getStatusCmd = new GetStatusType();
                getStatusCmd.setName("ForceTorqueSimGetPose" + getPoseCount.incrementAndGet());
                poseInConnectionStackCopy.writeCommand(getStatusCmd);
                CRCLStatusType newStatus = Objects.requireNonNull(poseInConnectionStackCopy.readStatus(), "poseInConnection.readStatus()");
                this.poseStatus = newStatus;
                final PoseStatusType newPoseStatus = Objects.requireNonNull(newStatus.getPoseStatus(), "newStatus.getPoseStatus()");
                final PoseType pose = Objects.requireNonNull(newPoseStatus.getPose(), "newPoseStatus.getPose()");
                return pose;
            } catch (CRCLException ex) {
                java.util.logging.Logger.getLogger(ForceTorqueSimJPanel.class.getName()).log(Level.SEVERE, null, ex);
                return null;
            }
        } else {
            return null;
        }
    }

    private volatile @Nullable
    Thread getPoseServiceThread = null;

    private static final AtomicInteger tcount = new AtomicInteger();

    private final ThreadFactory getPoseServiceThreadFactory
            = new ThreadFactory() {
        @Override
        public Thread newThread(Runnable r) {
            Thread thread = new Thread(r, tcount.incrementAndGet() + "ForceTorqueSimGetPose" + getPoseCRCLPort());
            thread.setDaemon(true);
            getPoseServiceThread = thread;
            return thread;
        }
    };

    private final ExecutorService getPoseService = Executors.newSingleThreadExecutor(getPoseServiceThreadFactory);

    @SuppressWarnings("nullness")
    private XFuture<@Nullable PoseType> getPoseFuture() {
        if (null == poseInConnection) {
            return XFuture.completedFuture(null);
        }
        return XFuture.supplyAsync("getPoseFuture", this::getPose, getPoseService);
    }

    public void startServer() {
        int port = Integer.parseInt(jTextFieldCRCLSensorOutPort.getText());
        try {
            startServer(port);
        } catch (Exception ex) {
            LOGGER.log(Level.SEVERE, "port=" + port, ex);
        }
    }

    private void startServer(int port) throws IOException {
        if (!jCheckBoxStartSensorOutServer.isSelected()) {
            jCheckBoxStartSensorOutServer.setSelected(true);
        }
        crclServerSocket = new CRCLServerSocket<>(port, FORCE_TORQUE_SIM_STATE_GENERATOR);
        crclServerSocket.addListener(crclSocketEventListener);
        crclServerSocket.setServerSideStatus(statusOut);
        crclServerSocket.setAutomaticallySendServerSideStatus(true);
        crclServerSocket.setAutomaticallyConvertUnits(true);
        crclServerSocket.setUpdateStatusSupplier(this::updateSensorStatus);
        crclServerSocket.start();
        updateSensorStatus();
    }

    public static class ForceTorqueSimClientState extends CRCLServerClientState {

        public ForceTorqueSimClientState(CRCLSocket cs) {
            super(cs);
            final ConfigureStatusReportType configureStatusReportType = new ConfigureStatusReportType();
            configureStatusReportType.setReportGripperStatus(false);
            configureStatusReportType.setReportPoseStatus(false);
            configureStatusReportType.setReportSettingsStatus(false);
            configureStatusReportType.setReportJointStatuses(false);
            configureStatusReportType.setReportSensorsStatus(true);
            super.filterSettings.setConfigureStatusReport(configureStatusReportType);
        }
        int i;
    }
    private final CRCLStatusType statusOut;
    private final ForceTorqueSensorStatusType sensorStatus;

    public static final CRCLServerSocketStateGenerator<ForceTorqueSimClientState> FORCE_TORQUE_SIM_STATE_GENERATOR
            = ForceTorqueSimClientState::new;

    @SuppressWarnings("initialization")
    private final CRCLServerSocketEventListener<ForceTorqueSimClientState> crclSocketEventListener
            = this::handleCrclServerSocketEvent;

    private @Nullable
    CRCLServerSocket<ForceTorqueSimClientState> crclServerSocket;

    private void handleCrclServerSocketEvent(CRCLServerSocketEvent<ForceTorqueSimClientState> evt) {

    }

    private XFuture<CRCLStatusType> updateSensorStatus() {
        XFuture<@Nullable PoseType> f = getPoseFuture();
        return f.thenCompose((PoseType pose) -> {
            return updateSensorStatusWithPose(pose);
        });
    }

    private XFuture<CRCLStatusType> updateSensorStatusWithPose(@Nullable PoseType pose) {
        double xposeEffect = 0.0;
        double yposeEffect = 0.0;
        double zposeEffect = 0.0;
        if (null != pose) {
            final PointType point = pose.getPoint();
            if (null != point) {
                double x = point.getX();
                double y = point.getY();
                double z = point.getZ();
                for (int i = 0; i < jTableObjects.getRowCount(); i++) {
                    double xmin = (Double) jTableObjects.getModel().getValueAt(i, 1);
                    double ymin = (Double) jTableObjects.getModel().getValueAt(i, 2);
                    double zmin = (Double) jTableObjects.getModel().getValueAt(i, 3);
                    double xmax = (Double) jTableObjects.getModel().getValueAt(i, 4);
                    double ymax = (Double) jTableObjects.getModel().getValueAt(i, 5);
                    double zmax = (Double) jTableObjects.getModel().getValueAt(i, 6);
                    double xscale = (Double) jTableObjects.getModel().getValueAt(i, 7);
                    double yscale = (Double) jTableObjects.getModel().getValueAt(i, 8);
                    double zscale = (Double) jTableObjects.getModel().getValueAt(i, 9);
                    if (x > xmin && x < xmax
                            && y > ymin && y < ymax
                            && z > zmin && z < zmax) {
                        double xdiff = Math.min(x - xmin, xmax - x);
                        double ydiff = Math.min(y - ymin, ymax - y);
                        double zdiff = Math.min(z - zmin, zmax - z);
                        xposeEffect += xscale * xdiff;
                        yposeEffect += yscale * ydiff;
                        zposeEffect += zscale * zdiff;
                    }
                }
            }
        }
        return completeUpdateStatus(xposeEffect, yposeEffect, zposeEffect);
    }

    private XFuture<CRCLStatusType> completeUpdateStatus(double xposeEffect, double yposeEffect, double zposeEffect) {
        final double fxValue = valueJPanelFx.getValue();
        final double fyValue = valueJPanelFy.getValue();
        final double fzValue = valueJPanelFz.getValue();
        final double txValue = valueJPanelTx.getValue();
        final double tyValue = valueJPanelTy.getValue();
        final double tzValue = valueJPanelTz.getValue();
        synchronized (sensorStatus) {
            sensorStatus.setFx(fxValue + xposeEffect);
            sensorStatus.setFy(fyValue + yposeEffect);
            sensorStatus.setFz(fzValue + zposeEffect);
            sensorStatus.setTx(txValue);
            sensorStatus.setTy(tyValue);
            sensorStatus.setTz(tzValue);
            sensorStatus.setSensorID("ForceTorqueSim");
        }
        final ForceTorqueSensorStatusType sensorStatusCopy = CRCLCopier.copy(sensorStatus);
        if (null != sensorStatusCopy) {
            javax.swing.SwingUtilities.invokeLater(() -> updateForceTorqueDisplay(sensorStatusCopy));
        }
        return XFuture.completedFuture(statusOut);
    }

    private void updateForceTorqueDisplay(ForceTorqueSensorStatusType sensorStatusCopy) {
        jTablePoseForceOut.setValueAt(sensorStatusCopy.getFx(), 0, 1);
        jTablePoseForceOut.setValueAt(sensorStatusCopy.getFy(), 1, 1);
        jTablePoseForceOut.setValueAt(sensorStatusCopy.getFz(), 2, 1);
        jTablePoseForceOut.setValueAt(sensorStatusCopy.getTx(), 3, 1);
        jTablePoseForceOut.setValueAt(sensorStatusCopy.getTy(), 4, 1);
        jTablePoseForceOut.setValueAt(sensorStatusCopy.getTz(), 5, 1);
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButton1;
    private javax.swing.JButton jButtonAddObject;
    private javax.swing.JButton jButtonDeleteObject;
    private javax.swing.JButton jButtonOpenObjectsFile;
    private javax.swing.JButton jButtonSaveObjectsFile;
    private javax.swing.JCheckBox jCheckBoxEnablePoseInConnection;
    private javax.swing.JCheckBox jCheckBoxStartSensorOutServer;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JMenu jMenu1;
    private javax.swing.JMenu jMenu2;
    final javax.swing.JMenuBar jMenuBar1 = new javax.swing.JMenuBar();
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JPanel jPanelCRCLPositionIn;
    private javax.swing.JPanel jPanelCommunications;
    private javax.swing.JPanel jPanelCrclSensorServerOut;
    private javax.swing.JPanel jPanelForceOut;
    private javax.swing.JPanel jPanelOffsets;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTabbedPane jTabbedPane1;
    private javax.swing.JTable jTableObjects;
    private javax.swing.JTable jTablePose;
    private javax.swing.JTable jTablePoseForceOut;
    private javax.swing.JTextField jTextFieldCRCLSensorOutPort;
    private javax.swing.JTextField jTextFieldObjectsFile;
    private javax.swing.JTextField jTextFieldPoseCRCLHost;
    private javax.swing.JTextField jTextFieldPoseCRCLPort;
    private crcl.ui.forcetorquesensorsimulator.ValueJPanel valueJPanelFx;
    private crcl.ui.forcetorquesensorsimulator.ValueJPanel valueJPanelFy;
    private crcl.ui.forcetorquesensorsimulator.ValueJPanel valueJPanelFz;
    private crcl.ui.forcetorquesensorsimulator.ValueJPanel valueJPanelTx;
    private crcl.ui.forcetorquesensorsimulator.ValueJPanel valueJPanelTy;
    private crcl.ui.forcetorquesensorsimulator.ValueJPanel valueJPanelTz;
    // End of variables declaration//GEN-END:variables
}
