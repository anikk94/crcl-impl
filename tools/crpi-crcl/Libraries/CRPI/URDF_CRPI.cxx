// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "URDF_CRPI.hxx"

// pose
// 

const pose::xyz_type& pose::
xyz () const
{
  return this->xyz_.get ();
}

pose::xyz_type& pose::
xyz ()
{
  return this->xyz_.get ();
}

void pose::
xyz (const xyz_type& x)
{
  this->xyz_.set (x);
}

void pose::
xyz (::std::auto_ptr< xyz_type > x)
{
  this->xyz_.set (x);
}

const pose::xyz_type& pose::
xyz_default_value ()
{
  return xyz_default_value_;
}

const pose::rpy_type& pose::
rpy () const
{
  return this->rpy_.get ();
}

pose::rpy_type& pose::
rpy ()
{
  return this->rpy_.get ();
}

void pose::
rpy (const rpy_type& x)
{
  this->rpy_.set (x);
}

void pose::
rpy (::std::auto_ptr< rpy_type > x)
{
  this->rpy_.set (x);
}

const pose::rpy_type& pose::
rpy_default_value ()
{
  return rpy_default_value_;
}


// color
// 

const color::rgba_type& color::
rgba () const
{
  return this->rgba_.get ();
}

color::rgba_type& color::
rgba ()
{
  return this->rgba_.get ();
}

void color::
rgba (const rgba_type& x)
{
  this->rgba_.set (x);
}

void color::
rgba (::std::auto_ptr< rgba_type > x)
{
  this->rgba_.set (x);
}

const color::rgba_type& color::
rgba_default_value ()
{
  return rgba_default_value_;
}


// verbose
// 

const verbose::value_optional& verbose::
value () const
{
  return this->value_;
}

verbose::value_optional& verbose::
value ()
{
  return this->value_;
}

void verbose::
value (const value_type& x)
{
  this->value_.set (x);
}

void verbose::
value (const value_optional& x)
{
  this->value_ = x;
}

void verbose::
value (::std::auto_ptr< value_type > x)
{
  this->value_.set (x);
}


// name
// 

const name::name1_optional& name::
name1 () const
{
  return this->name1_;
}

name::name1_optional& name::
name1 ()
{
  return this->name1_;
}

void name::
name1 (const name1_type& x)
{
  this->name1_.set (x);
}

void name::
name1 (const name1_optional& x)
{
  this->name1_ = x;
}

void name::
name1 (::std::auto_ptr< name1_type > x)
{
  this->name1_.set (x);
}


// mass
// 

const mass::value_type& mass::
value () const
{
  return this->value_.get ();
}

mass::value_type& mass::
value ()
{
  return this->value_.get ();
}

void mass::
value (const value_type& x)
{
  this->value_.set (x);
}

mass::value_type mass::
value_default_value ()
{
  return value_type (0.0);
}


// inertia
// 

const inertia::ixx_type& inertia::
ixx () const
{
  return this->ixx_.get ();
}

inertia::ixx_type& inertia::
ixx ()
{
  return this->ixx_.get ();
}

void inertia::
ixx (const ixx_type& x)
{
  this->ixx_.set (x);
}

inertia::ixx_type inertia::
ixx_default_value ()
{
  return ixx_type (0.0);
}

const inertia::ixy_type& inertia::
ixy () const
{
  return this->ixy_.get ();
}

inertia::ixy_type& inertia::
ixy ()
{
  return this->ixy_.get ();
}

void inertia::
ixy (const ixy_type& x)
{
  this->ixy_.set (x);
}

inertia::ixy_type inertia::
ixy_default_value ()
{
  return ixy_type (0.0);
}

const inertia::ixz_type& inertia::
ixz () const
{
  return this->ixz_.get ();
}

inertia::ixz_type& inertia::
ixz ()
{
  return this->ixz_.get ();
}

void inertia::
ixz (const ixz_type& x)
{
  this->ixz_.set (x);
}

inertia::ixz_type inertia::
ixz_default_value ()
{
  return ixz_type (0.0);
}

const inertia::iyy_type& inertia::
iyy () const
{
  return this->iyy_.get ();
}

inertia::iyy_type& inertia::
iyy ()
{
  return this->iyy_.get ();
}

void inertia::
iyy (const iyy_type& x)
{
  this->iyy_.set (x);
}

inertia::iyy_type inertia::
iyy_default_value ()
{
  return iyy_type (0.0);
}

const inertia::iyz_type& inertia::
iyz () const
{
  return this->iyz_.get ();
}

inertia::iyz_type& inertia::
iyz ()
{
  return this->iyz_.get ();
}

void inertia::
iyz (const iyz_type& x)
{
  this->iyz_.set (x);
}

inertia::iyz_type inertia::
iyz_default_value ()
{
  return iyz_type (0.0);
}

const inertia::izz_type& inertia::
izz () const
{
  return this->izz_.get ();
}

inertia::izz_type& inertia::
izz ()
{
  return this->izz_.get ();
}

void inertia::
izz (const izz_type& x)
{
  this->izz_.set (x);
}

inertia::izz_type inertia::
izz_default_value ()
{
  return izz_type (0.0);
}


// inertial
// 

const inertial::origin_optional& inertial::
origin () const
{
  return this->origin_;
}

inertial::origin_optional& inertial::
origin ()
{
  return this->origin_;
}

void inertial::
origin (const origin_type& x)
{
  this->origin_.set (x);
}

void inertial::
origin (const origin_optional& x)
{
  this->origin_ = x;
}

void inertial::
origin (::std::auto_ptr< origin_type > x)
{
  this->origin_.set (x);
}

const inertial::mass_optional& inertial::
mass () const
{
  return this->mass_;
}

inertial::mass_optional& inertial::
mass ()
{
  return this->mass_;
}

void inertial::
mass (const mass_type& x)
{
  this->mass_.set (x);
}

void inertial::
mass (const mass_optional& x)
{
  this->mass_ = x;
}

void inertial::
mass (::std::auto_ptr< mass_type > x)
{
  this->mass_.set (x);
}

const inertial::inertia_optional& inertial::
inertia () const
{
  return this->inertia_;
}

inertial::inertia_optional& inertial::
inertia ()
{
  return this->inertia_;
}

void inertial::
inertia (const inertia_type& x)
{
  this->inertia_.set (x);
}

void inertial::
inertia (const inertia_optional& x)
{
  this->inertia_ = x;
}

void inertial::
inertia (::std::auto_ptr< inertia_type > x)
{
  this->inertia_.set (x);
}


// box
// 

const box::size_type& box::
size () const
{
  return this->size_.get ();
}

box::size_type& box::
size ()
{
  return this->size_.get ();
}

void box::
size (const size_type& x)
{
  this->size_.set (x);
}

void box::
size (::std::auto_ptr< size_type > x)
{
  this->size_.set (x);
}

const box::size_type& box::
size_default_value ()
{
  return size_default_value_;
}


// cylinder
// 

const cylinder::radius_type& cylinder::
radius () const
{
  return this->radius_.get ();
}

cylinder::radius_type& cylinder::
radius ()
{
  return this->radius_.get ();
}

void cylinder::
radius (const radius_type& x)
{
  this->radius_.set (x);
}

const cylinder::length_type& cylinder::
length () const
{
  return this->length_.get ();
}

cylinder::length_type& cylinder::
length ()
{
  return this->length_.get ();
}

void cylinder::
length (const length_type& x)
{
  this->length_.set (x);
}


// sphere
// 

const sphere::radius_type& sphere::
radius () const
{
  return this->radius_.get ();
}

sphere::radius_type& sphere::
radius ()
{
  return this->radius_.get ();
}

void sphere::
radius (const radius_type& x)
{
  this->radius_.set (x);
}


// mesh
// 

const mesh::filename_type& mesh::
filename () const
{
  return this->filename_.get ();
}

mesh::filename_type& mesh::
filename ()
{
  return this->filename_.get ();
}

void mesh::
filename (const filename_type& x)
{
  this->filename_.set (x);
}

void mesh::
filename (::std::auto_ptr< filename_type > x)
{
  this->filename_.set (x);
}

const mesh::scale_type& mesh::
scale () const
{
  return this->scale_.get ();
}

mesh::scale_type& mesh::
scale ()
{
  return this->scale_.get ();
}

void mesh::
scale (const scale_type& x)
{
  this->scale_.set (x);
}

void mesh::
scale (::std::auto_ptr< scale_type > x)
{
  this->scale_.set (x);
}

const mesh::scale_type& mesh::
scale_default_value ()
{
  return scale_default_value_;
}


// geometry
// 

const geometry::box_optional& geometry::
box () const
{
  return this->box_;
}

geometry::box_optional& geometry::
box ()
{
  return this->box_;
}

void geometry::
box (const box_type& x)
{
  this->box_.set (x);
}

void geometry::
box (const box_optional& x)
{
  this->box_ = x;
}

void geometry::
box (::std::auto_ptr< box_type > x)
{
  this->box_.set (x);
}

const geometry::cylinder_optional& geometry::
cylinder () const
{
  return this->cylinder_;
}

geometry::cylinder_optional& geometry::
cylinder ()
{
  return this->cylinder_;
}

void geometry::
cylinder (const cylinder_type& x)
{
  this->cylinder_.set (x);
}

void geometry::
cylinder (const cylinder_optional& x)
{
  this->cylinder_ = x;
}

void geometry::
cylinder (::std::auto_ptr< cylinder_type > x)
{
  this->cylinder_.set (x);
}

const geometry::sphere_optional& geometry::
sphere () const
{
  return this->sphere_;
}

geometry::sphere_optional& geometry::
sphere ()
{
  return this->sphere_;
}

void geometry::
sphere (const sphere_type& x)
{
  this->sphere_.set (x);
}

void geometry::
sphere (const sphere_optional& x)
{
  this->sphere_ = x;
}

void geometry::
sphere (::std::auto_ptr< sphere_type > x)
{
  this->sphere_.set (x);
}

const geometry::mesh_optional& geometry::
mesh () const
{
  return this->mesh_;
}

geometry::mesh_optional& geometry::
mesh ()
{
  return this->mesh_;
}

void geometry::
mesh (const mesh_type& x)
{
  this->mesh_.set (x);
}

void geometry::
mesh (const mesh_optional& x)
{
  this->mesh_ = x;
}

void geometry::
mesh (::std::auto_ptr< mesh_type > x)
{
  this->mesh_.set (x);
}


// texture
// 

const texture::filename_optional& texture::
filename () const
{
  return this->filename_;
}

texture::filename_optional& texture::
filename ()
{
  return this->filename_;
}

void texture::
filename (const filename_type& x)
{
  this->filename_.set (x);
}

void texture::
filename (const filename_optional& x)
{
  this->filename_ = x;
}

void texture::
filename (::std::auto_ptr< filename_type > x)
{
  this->filename_.set (x);
}


// material
// 

const material::color_optional& material::
color () const
{
  return this->color_;
}

material::color_optional& material::
color ()
{
  return this->color_;
}

void material::
color (const color_type& x)
{
  this->color_.set (x);
}

void material::
color (const color_optional& x)
{
  this->color_ = x;
}

void material::
color (::std::auto_ptr< color_type > x)
{
  this->color_.set (x);
}

const material::texture_optional& material::
texture () const
{
  return this->texture_;
}

material::texture_optional& material::
texture ()
{
  return this->texture_;
}

void material::
texture (const texture_type& x)
{
  this->texture_.set (x);
}

void material::
texture (const texture_optional& x)
{
  this->texture_ = x;
}

void material::
texture (::std::auto_ptr< texture_type > x)
{
  this->texture_.set (x);
}

const material::name_optional& material::
name () const
{
  return this->name_;
}

material::name_optional& material::
name ()
{
  return this->name_;
}

void material::
name (const name_type& x)
{
  this->name_.set (x);
}

void material::
name (const name_optional& x)
{
  this->name_ = x;
}

void material::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}


// material_global
// 

const material_global::color_optional& material_global::
color () const
{
  return this->color_;
}

material_global::color_optional& material_global::
color ()
{
  return this->color_;
}

void material_global::
color (const color_type& x)
{
  this->color_.set (x);
}

void material_global::
color (const color_optional& x)
{
  this->color_ = x;
}

void material_global::
color (::std::auto_ptr< color_type > x)
{
  this->color_.set (x);
}

const material_global::texture_optional& material_global::
texture () const
{
  return this->texture_;
}

material_global::texture_optional& material_global::
texture ()
{
  return this->texture_;
}

void material_global::
texture (const texture_type& x)
{
  this->texture_.set (x);
}

void material_global::
texture (const texture_optional& x)
{
  this->texture_ = x;
}

void material_global::
texture (::std::auto_ptr< texture_type > x)
{
  this->texture_.set (x);
}

const material_global::name_type& material_global::
name () const
{
  return this->name_.get ();
}

material_global::name_type& material_global::
name ()
{
  return this->name_.get ();
}

void material_global::
name (const name_type& x)
{
  this->name_.set (x);
}

void material_global::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}


// visual
// 

const visual::origin_optional& visual::
origin () const
{
  return this->origin_;
}

visual::origin_optional& visual::
origin ()
{
  return this->origin_;
}

void visual::
origin (const origin_type& x)
{
  this->origin_.set (x);
}

void visual::
origin (const origin_optional& x)
{
  this->origin_ = x;
}

void visual::
origin (::std::auto_ptr< origin_type > x)
{
  this->origin_.set (x);
}

const visual::geometry_type& visual::
geometry () const
{
  return this->geometry_.get ();
}

visual::geometry_type& visual::
geometry ()
{
  return this->geometry_.get ();
}

void visual::
geometry (const geometry_type& x)
{
  this->geometry_.set (x);
}

void visual::
geometry (::std::auto_ptr< geometry_type > x)
{
  this->geometry_.set (x);
}

const visual::material_optional& visual::
material () const
{
  return this->material_;
}

visual::material_optional& visual::
material ()
{
  return this->material_;
}

void visual::
material (const material_type& x)
{
  this->material_.set (x);
}

void visual::
material (const material_optional& x)
{
  this->material_ = x;
}

void visual::
material (::std::auto_ptr< material_type > x)
{
  this->material_.set (x);
}


// collision
// 

const collision::origin_optional& collision::
origin () const
{
  return this->origin_;
}

collision::origin_optional& collision::
origin ()
{
  return this->origin_;
}

void collision::
origin (const origin_type& x)
{
  this->origin_.set (x);
}

void collision::
origin (const origin_optional& x)
{
  this->origin_ = x;
}

void collision::
origin (::std::auto_ptr< origin_type > x)
{
  this->origin_.set (x);
}

const collision::geometry_type& collision::
geometry () const
{
  return this->geometry_.get ();
}

collision::geometry_type& collision::
geometry ()
{
  return this->geometry_.get ();
}

void collision::
geometry (const geometry_type& x)
{
  this->geometry_.set (x);
}

void collision::
geometry (::std::auto_ptr< geometry_type > x)
{
  this->geometry_.set (x);
}

const collision::verbose_optional& collision::
verbose () const
{
  return this->verbose_;
}

collision::verbose_optional& collision::
verbose ()
{
  return this->verbose_;
}

void collision::
verbose (const verbose_type& x)
{
  this->verbose_.set (x);
}

void collision::
verbose (const verbose_optional& x)
{
  this->verbose_ = x;
}

void collision::
verbose (::std::auto_ptr< verbose_type > x)
{
  this->verbose_.set (x);
}

const collision::name_optional& collision::
name () const
{
  return this->name_;
}

collision::name_optional& collision::
name ()
{
  return this->name_;
}

void collision::
name (const name_type& x)
{
  this->name_.set (x);
}

void collision::
name (const name_optional& x)
{
  this->name_ = x;
}

void collision::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}


// link
// 

const link::inertial_optional& link::
inertial () const
{
  return this->inertial_;
}

link::inertial_optional& link::
inertial ()
{
  return this->inertial_;
}

void link::
inertial (const inertial_type& x)
{
  this->inertial_.set (x);
}

void link::
inertial (const inertial_optional& x)
{
  this->inertial_ = x;
}

void link::
inertial (::std::auto_ptr< inertial_type > x)
{
  this->inertial_.set (x);
}

const link::visual_optional& link::
visual () const
{
  return this->visual_;
}

link::visual_optional& link::
visual ()
{
  return this->visual_;
}

void link::
visual (const visual_type& x)
{
  this->visual_.set (x);
}

void link::
visual (const visual_optional& x)
{
  this->visual_ = x;
}

void link::
visual (::std::auto_ptr< visual_type > x)
{
  this->visual_.set (x);
}

const link::collision_optional& link::
collision () const
{
  return this->collision_;
}

link::collision_optional& link::
collision ()
{
  return this->collision_;
}

void link::
collision (const collision_type& x)
{
  this->collision_.set (x);
}

void link::
collision (const collision_optional& x)
{
  this->collision_ = x;
}

void link::
collision (::std::auto_ptr< collision_type > x)
{
  this->collision_.set (x);
}

const link::name_type& link::
name () const
{
  return this->name_.get ();
}

link::name_type& link::
name ()
{
  return this->name_.get ();
}

void link::
name (const name_type& x)
{
  this->name_.set (x);
}

void link::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}

const link::type_optional& link::
type () const
{
  return this->type_;
}

link::type_optional& link::
type ()
{
  return this->type_;
}

void link::
type (const type_type& x)
{
  this->type_.set (x);
}

void link::
type (const type_optional& x)
{
  this->type_ = x;
}

void link::
type (::std::auto_ptr< type_type > x)
{
  this->type_.set (x);
}


// parent
// 

const parent::link_type& parent::
link () const
{
  return this->link_.get ();
}

parent::link_type& parent::
link ()
{
  return this->link_.get ();
}

void parent::
link (const link_type& x)
{
  this->link_.set (x);
}

void parent::
link (::std::auto_ptr< link_type > x)
{
  this->link_.set (x);
}


// child
// 

const child::link_type& child::
link () const
{
  return this->link_.get ();
}

child::link_type& child::
link ()
{
  return this->link_.get ();
}

void child::
link (const link_type& x)
{
  this->link_.set (x);
}

void child::
link (::std::auto_ptr< link_type > x)
{
  this->link_.set (x);
}


// axis
// 

const axis::xyz_type& axis::
xyz () const
{
  return this->xyz_.get ();
}

axis::xyz_type& axis::
xyz ()
{
  return this->xyz_.get ();
}

void axis::
xyz (const xyz_type& x)
{
  this->xyz_.set (x);
}

void axis::
xyz (::std::auto_ptr< xyz_type > x)
{
  this->xyz_.set (x);
}

const axis::xyz_type& axis::
xyz_default_value ()
{
  return xyz_default_value_;
}


// calibration
// 

const calibration::reference_position_optional& calibration::
reference_position () const
{
  return this->reference_position_;
}

calibration::reference_position_optional& calibration::
reference_position ()
{
  return this->reference_position_;
}

void calibration::
reference_position (const reference_position_type& x)
{
  this->reference_position_.set (x);
}

void calibration::
reference_position (const reference_position_optional& x)
{
  this->reference_position_ = x;
}

const calibration::rising_optional& calibration::
rising () const
{
  return this->rising_;
}

calibration::rising_optional& calibration::
rising ()
{
  return this->rising_;
}

void calibration::
rising (const rising_type& x)
{
  this->rising_.set (x);
}

void calibration::
rising (const rising_optional& x)
{
  this->rising_ = x;
}

const calibration::falling_optional& calibration::
falling () const
{
  return this->falling_;
}

calibration::falling_optional& calibration::
falling ()
{
  return this->falling_;
}

void calibration::
falling (const falling_type& x)
{
  this->falling_.set (x);
}

void calibration::
falling (const falling_optional& x)
{
  this->falling_ = x;
}


// dynamics
// 

const dynamics::damping_type& dynamics::
damping () const
{
  return this->damping_.get ();
}

dynamics::damping_type& dynamics::
damping ()
{
  return this->damping_.get ();
}

void dynamics::
damping (const damping_type& x)
{
  this->damping_.set (x);
}

dynamics::damping_type dynamics::
damping_default_value ()
{
  return damping_type (0.0);
}

const dynamics::friction_type& dynamics::
friction () const
{
  return this->friction_.get ();
}

dynamics::friction_type& dynamics::
friction ()
{
  return this->friction_.get ();
}

void dynamics::
friction (const friction_type& x)
{
  this->friction_.set (x);
}

dynamics::friction_type dynamics::
friction_default_value ()
{
  return friction_type (0.0);
}


// limit
// 

const limit::lower_type& limit::
lower () const
{
  return this->lower_.get ();
}

limit::lower_type& limit::
lower ()
{
  return this->lower_.get ();
}

void limit::
lower (const lower_type& x)
{
  this->lower_.set (x);
}

limit::lower_type limit::
lower_default_value ()
{
  return lower_type (0.0);
}

const limit::upper_type& limit::
upper () const
{
  return this->upper_.get ();
}

limit::upper_type& limit::
upper ()
{
  return this->upper_.get ();
}

void limit::
upper (const upper_type& x)
{
  this->upper_.set (x);
}

limit::upper_type limit::
upper_default_value ()
{
  return upper_type (0.0);
}

const limit::effort_type& limit::
effort () const
{
  return this->effort_.get ();
}

limit::effort_type& limit::
effort ()
{
  return this->effort_.get ();
}

void limit::
effort (const effort_type& x)
{
  this->effort_.set (x);
}

limit::effort_type limit::
effort_default_value ()
{
  return effort_type (0.0);
}

const limit::velocity_type& limit::
velocity () const
{
  return this->velocity_.get ();
}

limit::velocity_type& limit::
velocity ()
{
  return this->velocity_.get ();
}

void limit::
velocity (const velocity_type& x)
{
  this->velocity_.set (x);
}

limit::velocity_type limit::
velocity_default_value ()
{
  return velocity_type (0.0);
}


// safety_controller
// 

const safety_controller::soft_lower_limit_type& safety_controller::
soft_lower_limit () const
{
  return this->soft_lower_limit_.get ();
}

safety_controller::soft_lower_limit_type& safety_controller::
soft_lower_limit ()
{
  return this->soft_lower_limit_.get ();
}

void safety_controller::
soft_lower_limit (const soft_lower_limit_type& x)
{
  this->soft_lower_limit_.set (x);
}

safety_controller::soft_lower_limit_type safety_controller::
soft_lower_limit_default_value ()
{
  return soft_lower_limit_type (0.0);
}

const safety_controller::soft_upper_limit_type& safety_controller::
soft_upper_limit () const
{
  return this->soft_upper_limit_.get ();
}

safety_controller::soft_upper_limit_type& safety_controller::
soft_upper_limit ()
{
  return this->soft_upper_limit_.get ();
}

void safety_controller::
soft_upper_limit (const soft_upper_limit_type& x)
{
  this->soft_upper_limit_.set (x);
}

safety_controller::soft_upper_limit_type safety_controller::
soft_upper_limit_default_value ()
{
  return soft_upper_limit_type (0.0);
}

const safety_controller::k_position_type& safety_controller::
k_position () const
{
  return this->k_position_.get ();
}

safety_controller::k_position_type& safety_controller::
k_position ()
{
  return this->k_position_.get ();
}

void safety_controller::
k_position (const k_position_type& x)
{
  this->k_position_.set (x);
}

safety_controller::k_position_type safety_controller::
k_position_default_value ()
{
  return k_position_type (0.0);
}

const safety_controller::k_velocity_type& safety_controller::
k_velocity () const
{
  return this->k_velocity_.get ();
}

safety_controller::k_velocity_type& safety_controller::
k_velocity ()
{
  return this->k_velocity_.get ();
}

void safety_controller::
k_velocity (const k_velocity_type& x)
{
  this->k_velocity_.set (x);
}


// mimic
// 

const mimic::joint_type& mimic::
joint () const
{
  return this->joint_.get ();
}

mimic::joint_type& mimic::
joint ()
{
  return this->joint_.get ();
}

void mimic::
joint (const joint_type& x)
{
  this->joint_.set (x);
}

void mimic::
joint (::std::auto_ptr< joint_type > x)
{
  this->joint_.set (x);
}

const mimic::multiplier_type& mimic::
multiplier () const
{
  return this->multiplier_.get ();
}

mimic::multiplier_type& mimic::
multiplier ()
{
  return this->multiplier_.get ();
}

void mimic::
multiplier (const multiplier_type& x)
{
  this->multiplier_.set (x);
}

mimic::multiplier_type mimic::
multiplier_default_value ()
{
  return multiplier_type (1.0);
}

const mimic::offset_type& mimic::
offset () const
{
  return this->offset_.get ();
}

mimic::offset_type& mimic::
offset ()
{
  return this->offset_.get ();
}

void mimic::
offset (const offset_type& x)
{
  this->offset_.set (x);
}

mimic::offset_type mimic::
offset_default_value ()
{
  return offset_type (0.0);
}


// actuator_transmission
// 

const actuator_transmission::mechanicalReduction_type& actuator_transmission::
mechanicalReduction () const
{
  return this->mechanicalReduction_.get ();
}

actuator_transmission::mechanicalReduction_type& actuator_transmission::
mechanicalReduction ()
{
  return this->mechanicalReduction_.get ();
}

void actuator_transmission::
mechanicalReduction (const mechanicalReduction_type& x)
{
  this->mechanicalReduction_.set (x);
}

const actuator_transmission::name_type& actuator_transmission::
name () const
{
  return this->name_.get ();
}

actuator_transmission::name_type& actuator_transmission::
name ()
{
  return this->name_.get ();
}

void actuator_transmission::
name (const name_type& x)
{
  this->name_.set (x);
}

void actuator_transmission::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}


// gap_joint_transmission
// 

const gap_joint_transmission::L0_type& gap_joint_transmission::
L0 () const
{
  return this->L0_.get ();
}

gap_joint_transmission::L0_type& gap_joint_transmission::
L0 ()
{
  return this->L0_.get ();
}

void gap_joint_transmission::
L0 (const L0_type& x)
{
  this->L0_.set (x);
}

const gap_joint_transmission::a_type& gap_joint_transmission::
a () const
{
  return this->a_.get ();
}

gap_joint_transmission::a_type& gap_joint_transmission::
a ()
{
  return this->a_.get ();
}

void gap_joint_transmission::
a (const a_type& x)
{
  this->a_.set (x);
}

const gap_joint_transmission::b_type& gap_joint_transmission::
b () const
{
  return this->b_.get ();
}

gap_joint_transmission::b_type& gap_joint_transmission::
b ()
{
  return this->b_.get ();
}

void gap_joint_transmission::
b (const b_type& x)
{
  this->b_.set (x);
}

const gap_joint_transmission::gear_ratio_type& gap_joint_transmission::
gear_ratio () const
{
  return this->gear_ratio_.get ();
}

gap_joint_transmission::gear_ratio_type& gap_joint_transmission::
gear_ratio ()
{
  return this->gear_ratio_.get ();
}

void gap_joint_transmission::
gear_ratio (const gear_ratio_type& x)
{
  this->gear_ratio_.set (x);
}

const gap_joint_transmission::h_type& gap_joint_transmission::
h () const
{
  return this->h_.get ();
}

gap_joint_transmission::h_type& gap_joint_transmission::
h ()
{
  return this->h_.get ();
}

void gap_joint_transmission::
h (const h_type& x)
{
  this->h_.set (x);
}

const gap_joint_transmission::mechanical_reduction_type& gap_joint_transmission::
mechanical_reduction () const
{
  return this->mechanical_reduction_.get ();
}

gap_joint_transmission::mechanical_reduction_type& gap_joint_transmission::
mechanical_reduction ()
{
  return this->mechanical_reduction_.get ();
}

void gap_joint_transmission::
mechanical_reduction (const mechanical_reduction_type& x)
{
  this->mechanical_reduction_.set (x);
}

const gap_joint_transmission::name_type& gap_joint_transmission::
name () const
{
  return this->name_.get ();
}

gap_joint_transmission::name_type& gap_joint_transmission::
name ()
{
  return this->name_.get ();
}

void gap_joint_transmission::
name (const name_type& x)
{
  this->name_.set (x);
}

void gap_joint_transmission::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}

const gap_joint_transmission::phi0_type& gap_joint_transmission::
phi0 () const
{
  return this->phi0_.get ();
}

gap_joint_transmission::phi0_type& gap_joint_transmission::
phi0 ()
{
  return this->phi0_.get ();
}

void gap_joint_transmission::
phi0 (const phi0_type& x)
{
  this->phi0_.set (x);
}

const gap_joint_transmission::r_type& gap_joint_transmission::
r () const
{
  return this->r_.get ();
}

gap_joint_transmission::r_type& gap_joint_transmission::
r ()
{
  return this->r_.get ();
}

void gap_joint_transmission::
r (const r_type& x)
{
  this->r_.set (x);
}

const gap_joint_transmission::screw_reduction_type& gap_joint_transmission::
screw_reduction () const
{
  return this->screw_reduction_.get ();
}

gap_joint_transmission::screw_reduction_type& gap_joint_transmission::
screw_reduction ()
{
  return this->screw_reduction_.get ();
}

void gap_joint_transmission::
screw_reduction (const screw_reduction_type& x)
{
  this->screw_reduction_.set (x);
}

const gap_joint_transmission::t0_type& gap_joint_transmission::
t0 () const
{
  return this->t0_.get ();
}

gap_joint_transmission::t0_type& gap_joint_transmission::
t0 ()
{
  return this->t0_.get ();
}

void gap_joint_transmission::
t0 (const t0_type& x)
{
  this->t0_.set (x);
}

const gap_joint_transmission::theta0_type& gap_joint_transmission::
theta0 () const
{
  return this->theta0_.get ();
}

gap_joint_transmission::theta0_type& gap_joint_transmission::
theta0 ()
{
  return this->theta0_.get ();
}

void gap_joint_transmission::
theta0 (const theta0_type& x)
{
  this->theta0_.set (x);
}


// passive_joint_transmission
// 

const passive_joint_transmission::name_type& passive_joint_transmission::
name () const
{
  return this->name_.get ();
}

passive_joint_transmission::name_type& passive_joint_transmission::
name ()
{
  return this->name_.get ();
}

void passive_joint_transmission::
name (const name_type& x)
{
  this->name_.set (x);
}

void passive_joint_transmission::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}


// transmission
// 

const transmission::leftActuator_sequence& transmission::
leftActuator () const
{
  return this->leftActuator_;
}

transmission::leftActuator_sequence& transmission::
leftActuator ()
{
  return this->leftActuator_;
}

void transmission::
leftActuator (const leftActuator_sequence& s)
{
  this->leftActuator_ = s;
}

const transmission::rightActuator_sequence& transmission::
rightActuator () const
{
  return this->rightActuator_;
}

transmission::rightActuator_sequence& transmission::
rightActuator ()
{
  return this->rightActuator_;
}

void transmission::
rightActuator (const rightActuator_sequence& s)
{
  this->rightActuator_ = s;
}

const transmission::flexJoint_sequence& transmission::
flexJoint () const
{
  return this->flexJoint_;
}

transmission::flexJoint_sequence& transmission::
flexJoint ()
{
  return this->flexJoint_;
}

void transmission::
flexJoint (const flexJoint_sequence& s)
{
  this->flexJoint_ = s;
}

const transmission::rollJoint_sequence& transmission::
rollJoint () const
{
  return this->rollJoint_;
}

transmission::rollJoint_sequence& transmission::
rollJoint ()
{
  return this->rollJoint_;
}

void transmission::
rollJoint (const rollJoint_sequence& s)
{
  this->rollJoint_ = s;
}

const transmission::gap_joint_sequence& transmission::
gap_joint () const
{
  return this->gap_joint_;
}

transmission::gap_joint_sequence& transmission::
gap_joint ()
{
  return this->gap_joint_;
}

void transmission::
gap_joint (const gap_joint_sequence& s)
{
  this->gap_joint_ = s;
}

const transmission::passive_joint_sequence& transmission::
passive_joint () const
{
  return this->passive_joint_;
}

transmission::passive_joint_sequence& transmission::
passive_joint ()
{
  return this->passive_joint_;
}

void transmission::
passive_joint (const passive_joint_sequence& s)
{
  this->passive_joint_ = s;
}

const transmission::use_simulated_gripper_joint_sequence& transmission::
use_simulated_gripper_joint () const
{
  return this->use_simulated_gripper_joint_;
}

transmission::use_simulated_gripper_joint_sequence& transmission::
use_simulated_gripper_joint ()
{
  return this->use_simulated_gripper_joint_;
}

void transmission::
use_simulated_gripper_joint (const use_simulated_gripper_joint_sequence& s)
{
  this->use_simulated_gripper_joint_ = s;
}

const transmission::mechanicalReduction_sequence& transmission::
mechanicalReduction () const
{
  return this->mechanicalReduction_;
}

transmission::mechanicalReduction_sequence& transmission::
mechanicalReduction ()
{
  return this->mechanicalReduction_;
}

void transmission::
mechanicalReduction (const mechanicalReduction_sequence& s)
{
  this->mechanicalReduction_ = s;
}

const transmission::actuator_sequence& transmission::
actuator () const
{
  return this->actuator_;
}

transmission::actuator_sequence& transmission::
actuator ()
{
  return this->actuator_;
}

void transmission::
actuator (const actuator_sequence& s)
{
  this->actuator_ = s;
}

const transmission::joint_sequence& transmission::
joint () const
{
  return this->joint_;
}

transmission::joint_sequence& transmission::
joint ()
{
  return this->joint_;
}

void transmission::
joint (const joint_sequence& s)
{
  this->joint_ = s;
}

const transmission::name_type& transmission::
name () const
{
  return this->name_.get ();
}

transmission::name_type& transmission::
name ()
{
  return this->name_.get ();
}

void transmission::
name (const name_type& x)
{
  this->name_.set (x);
}

void transmission::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}

const transmission::type_type& transmission::
type () const
{
  return this->type_.get ();
}

transmission::type_type& transmission::
type ()
{
  return this->type_.get ();
}

void transmission::
type (const type_type& x)
{
  this->type_.set (x);
}

void transmission::
type (::std::auto_ptr< type_type > x)
{
  this->type_.set (x);
}


// joint
// 

const joint::origin_optional& joint::
origin () const
{
  return this->origin_;
}

joint::origin_optional& joint::
origin ()
{
  return this->origin_;
}

void joint::
origin (const origin_type& x)
{
  this->origin_.set (x);
}

void joint::
origin (const origin_optional& x)
{
  this->origin_ = x;
}

void joint::
origin (::std::auto_ptr< origin_type > x)
{
  this->origin_.set (x);
}

const joint::parent_type& joint::
parent () const
{
  return this->parent_.get ();
}

joint::parent_type& joint::
parent ()
{
  return this->parent_.get ();
}

void joint::
parent (const parent_type& x)
{
  this->parent_.set (x);
}

void joint::
parent (::std::auto_ptr< parent_type > x)
{
  this->parent_.set (x);
}

const joint::child_type& joint::
child () const
{
  return this->child_.get ();
}

joint::child_type& joint::
child ()
{
  return this->child_.get ();
}

void joint::
child (const child_type& x)
{
  this->child_.set (x);
}

void joint::
child (::std::auto_ptr< child_type > x)
{
  this->child_.set (x);
}

const joint::axis_optional& joint::
axis () const
{
  return this->axis_;
}

joint::axis_optional& joint::
axis ()
{
  return this->axis_;
}

void joint::
axis (const axis_type& x)
{
  this->axis_.set (x);
}

void joint::
axis (const axis_optional& x)
{
  this->axis_ = x;
}

void joint::
axis (::std::auto_ptr< axis_type > x)
{
  this->axis_.set (x);
}

const joint::calibration_optional& joint::
calibration () const
{
  return this->calibration_;
}

joint::calibration_optional& joint::
calibration ()
{
  return this->calibration_;
}

void joint::
calibration (const calibration_type& x)
{
  this->calibration_.set (x);
}

void joint::
calibration (const calibration_optional& x)
{
  this->calibration_ = x;
}

void joint::
calibration (::std::auto_ptr< calibration_type > x)
{
  this->calibration_.set (x);
}

const joint::dynamics_optional& joint::
dynamics () const
{
  return this->dynamics_;
}

joint::dynamics_optional& joint::
dynamics ()
{
  return this->dynamics_;
}

void joint::
dynamics (const dynamics_type& x)
{
  this->dynamics_.set (x);
}

void joint::
dynamics (const dynamics_optional& x)
{
  this->dynamics_ = x;
}

void joint::
dynamics (::std::auto_ptr< dynamics_type > x)
{
  this->dynamics_.set (x);
}

const joint::limit_optional& joint::
limit () const
{
  return this->limit_;
}

joint::limit_optional& joint::
limit ()
{
  return this->limit_;
}

void joint::
limit (const limit_type& x)
{
  this->limit_.set (x);
}

void joint::
limit (const limit_optional& x)
{
  this->limit_ = x;
}

void joint::
limit (::std::auto_ptr< limit_type > x)
{
  this->limit_.set (x);
}

const joint::safety_controller_optional& joint::
safety_controller () const
{
  return this->safety_controller_;
}

joint::safety_controller_optional& joint::
safety_controller ()
{
  return this->safety_controller_;
}

void joint::
safety_controller (const safety_controller_type& x)
{
  this->safety_controller_.set (x);
}

void joint::
safety_controller (const safety_controller_optional& x)
{
  this->safety_controller_ = x;
}

void joint::
safety_controller (::std::auto_ptr< safety_controller_type > x)
{
  this->safety_controller_.set (x);
}

const joint::mimic_optional& joint::
mimic () const
{
  return this->mimic_;
}

joint::mimic_optional& joint::
mimic ()
{
  return this->mimic_;
}

void joint::
mimic (const mimic_type& x)
{
  this->mimic_.set (x);
}

void joint::
mimic (const mimic_optional& x)
{
  this->mimic_ = x;
}

void joint::
mimic (::std::auto_ptr< mimic_type > x)
{
  this->mimic_.set (x);
}

const joint::name_type& joint::
name () const
{
  return this->name_.get ();
}

joint::name_type& joint::
name ()
{
  return this->name_.get ();
}

void joint::
name (const name_type& x)
{
  this->name_.set (x);
}

void joint::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}

const joint::type_type& joint::
type () const
{
  return this->type_.get ();
}

joint::type_type& joint::
type ()
{
  return this->type_.get ();
}

void joint::
type (const type_type& x)
{
  this->type_.set (x);
}

void joint::
type (::std::auto_ptr< type_type > x)
{
  this->type_.set (x);
}


// Debug
// 


// CrpiType
// 


// TCP_IP
// 

const TCP_IP::Address_type& TCP_IP::
Address () const
{
  return this->Address_.get ();
}

TCP_IP::Address_type& TCP_IP::
Address ()
{
  return this->Address_.get ();
}

void TCP_IP::
Address (const Address_type& x)
{
  this->Address_.set (x);
}

void TCP_IP::
Address (::std::auto_ptr< Address_type > x)
{
  this->Address_.set (x);
}

const TCP_IP::Port_type& TCP_IP::
Port () const
{
  return this->Port_.get ();
}

TCP_IP::Port_type& TCP_IP::
Port ()
{
  return this->Port_.get ();
}

void TCP_IP::
Port (const Port_type& x)
{
  this->Port_.set (x);
}

const TCP_IP::Client_type& TCP_IP::
Client () const
{
  return this->Client_.get ();
}

TCP_IP::Client_type& TCP_IP::
Client ()
{
  return this->Client_.get ();
}

void TCP_IP::
Client (const Client_type& x)
{
  this->Client_.set (x);
}


// ComType
// 

const ComType::Val_type& ComType::
Val () const
{
  return this->Val_.get ();
}

ComType::Val_type& ComType::
Val ()
{
  return this->Val_.get ();
}

void ComType::
Val (const Val_type& x)
{
  this->Val_.set (x);
}

void ComType::
Val (::std::auto_ptr< Val_type > x)
{
  this->Val_.set (x);
}


// CRCL_Robot
// 

const CRCL_Robot::Status_Request_Period_optional& CRCL_Robot::
Status_Request_Period () const
{
  return this->Status_Request_Period_;
}

CRCL_Robot::Status_Request_Period_optional& CRCL_Robot::
Status_Request_Period ()
{
  return this->Status_Request_Period_;
}

void CRCL_Robot::
Status_Request_Period (const Status_Request_Period_type& x)
{
  this->Status_Request_Period_.set (x);
}

void CRCL_Robot::
Status_Request_Period (const Status_Request_Period_optional& x)
{
  this->Status_Request_Period_ = x;
}

const CRCL_Robot::Command_Schema_optional& CRCL_Robot::
Command_Schema () const
{
  return this->Command_Schema_;
}

CRCL_Robot::Command_Schema_optional& CRCL_Robot::
Command_Schema ()
{
  return this->Command_Schema_;
}

void CRCL_Robot::
Command_Schema (const Command_Schema_type& x)
{
  this->Command_Schema_.set (x);
}

void CRCL_Robot::
Command_Schema (const Command_Schema_optional& x)
{
  this->Command_Schema_ = x;
}

void CRCL_Robot::
Command_Schema (::std::auto_ptr< Command_Schema_type > x)
{
  this->Command_Schema_.set (x);
}

const CRCL_Robot::Status_Schema_optional& CRCL_Robot::
Status_Schema () const
{
  return this->Status_Schema_;
}

CRCL_Robot::Status_Schema_optional& CRCL_Robot::
Status_Schema ()
{
  return this->Status_Schema_;
}

void CRCL_Robot::
Status_Schema (const Status_Schema_type& x)
{
  this->Status_Schema_.set (x);
}

void CRCL_Robot::
Status_Schema (const Status_Schema_optional& x)
{
  this->Status_Schema_ = x;
}

void CRCL_Robot::
Status_Schema (::std::auto_ptr< Status_Schema_type > x)
{
  this->Status_Schema_.set (x);
}


// Mounting
// 

const Mounting::X_type& Mounting::
X () const
{
  return this->X_.get ();
}

Mounting::X_type& Mounting::
X ()
{
  return this->X_.get ();
}

void Mounting::
X (const X_type& x)
{
  this->X_.set (x);
}

const Mounting::Y_type& Mounting::
Y () const
{
  return this->Y_.get ();
}

Mounting::Y_type& Mounting::
Y ()
{
  return this->Y_.get ();
}

void Mounting::
Y (const Y_type& x)
{
  this->Y_.set (x);
}

const Mounting::Z_type& Mounting::
Z () const
{
  return this->Z_.get ();
}

Mounting::Z_type& Mounting::
Z ()
{
  return this->Z_.get ();
}

void Mounting::
Z (const Z_type& x)
{
  this->Z_.set (x);
}

const Mounting::XR_type& Mounting::
XR () const
{
  return this->XR_.get ();
}

Mounting::XR_type& Mounting::
XR ()
{
  return this->XR_.get ();
}

void Mounting::
XR (const XR_type& x)
{
  this->XR_.set (x);
}

const Mounting::YR_type& Mounting::
YR () const
{
  return this->YR_.get ();
}

Mounting::YR_type& Mounting::
YR ()
{
  return this->YR_.get ();
}

void Mounting::
YR (const YR_type& x)
{
  this->YR_.set (x);
}

const Mounting::ZR_type& Mounting::
ZR () const
{
  return this->ZR_.get ();
}

Mounting::ZR_type& Mounting::
ZR ()
{
  return this->ZR_.get ();
}

void Mounting::
ZR (const ZR_type& x)
{
  this->ZR_.set (x);
}


// ToWorld
// 

const ToWorld::X_type& ToWorld::
X () const
{
  return this->X_.get ();
}

ToWorld::X_type& ToWorld::
X ()
{
  return this->X_.get ();
}

void ToWorld::
X (const X_type& x)
{
  this->X_.set (x);
}

const ToWorld::Y_type& ToWorld::
Y () const
{
  return this->Y_.get ();
}

ToWorld::Y_type& ToWorld::
Y ()
{
  return this->Y_.get ();
}

void ToWorld::
Y (const Y_type& x)
{
  this->Y_.set (x);
}

const ToWorld::Z_type& ToWorld::
Z () const
{
  return this->Z_.get ();
}

ToWorld::Z_type& ToWorld::
Z ()
{
  return this->Z_.get ();
}

void ToWorld::
Z (const Z_type& x)
{
  this->Z_.set (x);
}

const ToWorld::XR_type& ToWorld::
XR () const
{
  return this->XR_.get ();
}

ToWorld::XR_type& ToWorld::
XR ()
{
  return this->XR_.get ();
}

void ToWorld::
XR (const XR_type& x)
{
  this->XR_.set (x);
}

const ToWorld::YR_type& ToWorld::
YR () const
{
  return this->YR_.get ();
}

ToWorld::YR_type& ToWorld::
YR ()
{
  return this->YR_.get ();
}

void ToWorld::
YR (const YR_type& x)
{
  this->YR_.set (x);
}

const ToWorld::ZR_type& ToWorld::
ZR () const
{
  return this->ZR_.get ();
}

ToWorld::ZR_type& ToWorld::
ZR ()
{
  return this->ZR_.get ();
}

void ToWorld::
ZR (const ZR_type& x)
{
  this->ZR_.set (x);
}

const ToWorld::M00_optional& ToWorld::
M00 () const
{
  return this->M00_;
}

ToWorld::M00_optional& ToWorld::
M00 ()
{
  return this->M00_;
}

void ToWorld::
M00 (const M00_type& x)
{
  this->M00_.set (x);
}

void ToWorld::
M00 (const M00_optional& x)
{
  this->M00_ = x;
}

const ToWorld::M01_optional& ToWorld::
M01 () const
{
  return this->M01_;
}

ToWorld::M01_optional& ToWorld::
M01 ()
{
  return this->M01_;
}

void ToWorld::
M01 (const M01_type& x)
{
  this->M01_.set (x);
}

void ToWorld::
M01 (const M01_optional& x)
{
  this->M01_ = x;
}

const ToWorld::M02_optional& ToWorld::
M02 () const
{
  return this->M02_;
}

ToWorld::M02_optional& ToWorld::
M02 ()
{
  return this->M02_;
}

void ToWorld::
M02 (const M02_type& x)
{
  this->M02_.set (x);
}

void ToWorld::
M02 (const M02_optional& x)
{
  this->M02_ = x;
}

const ToWorld::M03_optional& ToWorld::
M03 () const
{
  return this->M03_;
}

ToWorld::M03_optional& ToWorld::
M03 ()
{
  return this->M03_;
}

void ToWorld::
M03 (const M03_type& x)
{
  this->M03_.set (x);
}

void ToWorld::
M03 (const M03_optional& x)
{
  this->M03_ = x;
}

const ToWorld::M10_optional& ToWorld::
M10 () const
{
  return this->M10_;
}

ToWorld::M10_optional& ToWorld::
M10 ()
{
  return this->M10_;
}

void ToWorld::
M10 (const M10_type& x)
{
  this->M10_.set (x);
}

void ToWorld::
M10 (const M10_optional& x)
{
  this->M10_ = x;
}

const ToWorld::M11_optional& ToWorld::
M11 () const
{
  return this->M11_;
}

ToWorld::M11_optional& ToWorld::
M11 ()
{
  return this->M11_;
}

void ToWorld::
M11 (const M11_type& x)
{
  this->M11_.set (x);
}

void ToWorld::
M11 (const M11_optional& x)
{
  this->M11_ = x;
}

const ToWorld::M12_optional& ToWorld::
M12 () const
{
  return this->M12_;
}

ToWorld::M12_optional& ToWorld::
M12 ()
{
  return this->M12_;
}

void ToWorld::
M12 (const M12_type& x)
{
  this->M12_.set (x);
}

void ToWorld::
M12 (const M12_optional& x)
{
  this->M12_ = x;
}

const ToWorld::M13_optional& ToWorld::
M13 () const
{
  return this->M13_;
}

ToWorld::M13_optional& ToWorld::
M13 ()
{
  return this->M13_;
}

void ToWorld::
M13 (const M13_type& x)
{
  this->M13_.set (x);
}

void ToWorld::
M13 (const M13_optional& x)
{
  this->M13_ = x;
}

const ToWorld::M20_optional& ToWorld::
M20 () const
{
  return this->M20_;
}

ToWorld::M20_optional& ToWorld::
M20 ()
{
  return this->M20_;
}

void ToWorld::
M20 (const M20_type& x)
{
  this->M20_.set (x);
}

void ToWorld::
M20 (const M20_optional& x)
{
  this->M20_ = x;
}

const ToWorld::M21_optional& ToWorld::
M21 () const
{
  return this->M21_;
}

ToWorld::M21_optional& ToWorld::
M21 ()
{
  return this->M21_;
}

void ToWorld::
M21 (const M21_type& x)
{
  this->M21_.set (x);
}

void ToWorld::
M21 (const M21_optional& x)
{
  this->M21_ = x;
}

const ToWorld::M22_optional& ToWorld::
M22 () const
{
  return this->M22_;
}

ToWorld::M22_optional& ToWorld::
M22 ()
{
  return this->M22_;
}

void ToWorld::
M22 (const M22_type& x)
{
  this->M22_.set (x);
}

void ToWorld::
M22 (const M22_optional& x)
{
  this->M22_ = x;
}

const ToWorld::M23_optional& ToWorld::
M23 () const
{
  return this->M23_;
}

ToWorld::M23_optional& ToWorld::
M23 ()
{
  return this->M23_;
}

void ToWorld::
M23 (const M23_type& x)
{
  this->M23_.set (x);
}

void ToWorld::
M23 (const M23_optional& x)
{
  this->M23_ = x;
}

const ToWorld::M30_optional& ToWorld::
M30 () const
{
  return this->M30_;
}

ToWorld::M30_optional& ToWorld::
M30 ()
{
  return this->M30_;
}

void ToWorld::
M30 (const M30_type& x)
{
  this->M30_.set (x);
}

void ToWorld::
M30 (const M30_optional& x)
{
  this->M30_ = x;
}

const ToWorld::M31_optional& ToWorld::
M31 () const
{
  return this->M31_;
}

ToWorld::M31_optional& ToWorld::
M31 ()
{
  return this->M31_;
}

void ToWorld::
M31 (const M31_type& x)
{
  this->M31_.set (x);
}

void ToWorld::
M31 (const M31_optional& x)
{
  this->M31_ = x;
}

const ToWorld::M32_optional& ToWorld::
M32 () const
{
  return this->M32_;
}

ToWorld::M32_optional& ToWorld::
M32 ()
{
  return this->M32_;
}

void ToWorld::
M32 (const M32_type& x)
{
  this->M32_.set (x);
}

void ToWorld::
M32 (const M32_optional& x)
{
  this->M32_ = x;
}

const ToWorld::M33_optional& ToWorld::
M33 () const
{
  return this->M33_;
}

ToWorld::M33_optional& ToWorld::
M33 ()
{
  return this->M33_;
}

void ToWorld::
M33 (const M33_type& x)
{
  this->M33_.set (x);
}

void ToWorld::
M33 (const M33_optional& x)
{
  this->M33_ = x;
}


// Tool
// 

const Tool::ID_type& Tool::
ID () const
{
  return this->ID_.get ();
}

Tool::ID_type& Tool::
ID ()
{
  return this->ID_.get ();
}

void Tool::
ID (const ID_type& x)
{
  this->ID_.set (x);
}

const Tool::Name_type& Tool::
Name () const
{
  return this->Name_.get ();
}

Tool::Name_type& Tool::
Name ()
{
  return this->Name_.get ();
}

void Tool::
Name (const Name_type& x)
{
  this->Name_.set (x);
}

void Tool::
Name (::std::auto_ptr< Name_type > x)
{
  this->Name_.set (x);
}

const Tool::X_type& Tool::
X () const
{
  return this->X_.get ();
}

Tool::X_type& Tool::
X ()
{
  return this->X_.get ();
}

void Tool::
X (const X_type& x)
{
  this->X_.set (x);
}

const Tool::Y_type& Tool::
Y () const
{
  return this->Y_.get ();
}

Tool::Y_type& Tool::
Y ()
{
  return this->Y_.get ();
}

void Tool::
Y (const Y_type& x)
{
  this->Y_.set (x);
}

const Tool::Z_type& Tool::
Z () const
{
  return this->Z_.get ();
}

Tool::Z_type& Tool::
Z ()
{
  return this->Z_.get ();
}

void Tool::
Z (const Z_type& x)
{
  this->Z_.set (x);
}

const Tool::XR_type& Tool::
XR () const
{
  return this->XR_.get ();
}

Tool::XR_type& Tool::
XR ()
{
  return this->XR_.get ();
}

void Tool::
XR (const XR_type& x)
{
  this->XR_.set (x);
}

const Tool::YR_type& Tool::
YR () const
{
  return this->YR_.get ();
}

Tool::YR_type& Tool::
YR ()
{
  return this->YR_.get ();
}

void Tool::
YR (const YR_type& x)
{
  this->YR_.set (x);
}

const Tool::ZR_type& Tool::
ZR () const
{
  return this->ZR_.get ();
}

Tool::ZR_type& Tool::
ZR ()
{
  return this->ZR_.get ();
}

void Tool::
ZR (const ZR_type& x)
{
  this->ZR_.set (x);
}

const Tool::Mass_optional& Tool::
Mass () const
{
  return this->Mass_;
}

Tool::Mass_optional& Tool::
Mass ()
{
  return this->Mass_;
}

void Tool::
Mass (const Mass_type& x)
{
  this->Mass_.set (x);
}

void Tool::
Mass (const Mass_optional& x)
{
  this->Mass_ = x;
}

const Tool::MX_optional& Tool::
MX () const
{
  return this->MX_;
}

Tool::MX_optional& Tool::
MX ()
{
  return this->MX_;
}

void Tool::
MX (const MX_type& x)
{
  this->MX_.set (x);
}

void Tool::
MX (const MX_optional& x)
{
  this->MX_ = x;
}

const Tool::MY_optional& Tool::
MY () const
{
  return this->MY_;
}

Tool::MY_optional& Tool::
MY ()
{
  return this->MY_;
}

void Tool::
MY (const MY_type& x)
{
  this->MY_.set (x);
}

void Tool::
MY (const MY_optional& x)
{
  this->MY_ = x;
}

const Tool::MZ_optional& Tool::
MZ () const
{
  return this->MZ_;
}

Tool::MZ_optional& Tool::
MZ ()
{
  return this->MZ_;
}

void Tool::
MZ (const MZ_type& x)
{
  this->MZ_.set (x);
}

void Tool::
MZ (const MZ_optional& x)
{
  this->MZ_ = x;
}


// use_simulated_gripper_joint
// 


// robot
// 

const robot::Debug_optional& robot::
Debug () const
{
  return this->Debug_;
}

robot::Debug_optional& robot::
Debug ()
{
  return this->Debug_;
}

void robot::
Debug (const Debug_type& x)
{
  this->Debug_.set (x);
}

void robot::
Debug (const Debug_optional& x)
{
  this->Debug_ = x;
}

void robot::
Debug (::std::auto_ptr< Debug_type > x)
{
  this->Debug_.set (x);
}

const robot::CrpiType_optional& robot::
CrpiType () const
{
  return this->CrpiType_;
}

robot::CrpiType_optional& robot::
CrpiType ()
{
  return this->CrpiType_;
}

void robot::
CrpiType (const CrpiType_type& x)
{
  this->CrpiType_.set (x);
}

void robot::
CrpiType (const CrpiType_optional& x)
{
  this->CrpiType_ = x;
}

void robot::
CrpiType (::std::auto_ptr< CrpiType_type > x)
{
  this->CrpiType_.set (x);
}

const robot::TCP_IP_type& robot::
TCP_IP () const
{
  return this->TCP_IP_.get ();
}

robot::TCP_IP_type& robot::
TCP_IP ()
{
  return this->TCP_IP_.get ();
}

void robot::
TCP_IP (const TCP_IP_type& x)
{
  this->TCP_IP_.set (x);
}

void robot::
TCP_IP (::std::auto_ptr< TCP_IP_type > x)
{
  this->TCP_IP_.set (x);
}

const robot::ComType_optional& robot::
ComType () const
{
  return this->ComType_;
}

robot::ComType_optional& robot::
ComType ()
{
  return this->ComType_;
}

void robot::
ComType (const ComType_type& x)
{
  this->ComType_.set (x);
}

void robot::
ComType (const ComType_optional& x)
{
  this->ComType_ = x;
}

void robot::
ComType (::std::auto_ptr< ComType_type > x)
{
  this->ComType_.set (x);
}

const robot::CRCL_Robot_optional& robot::
CRCL_Robot () const
{
  return this->CRCL_Robot_;
}

robot::CRCL_Robot_optional& robot::
CRCL_Robot ()
{
  return this->CRCL_Robot_;
}

void robot::
CRCL_Robot (const CRCL_Robot_type& x)
{
  this->CRCL_Robot_.set (x);
}

void robot::
CRCL_Robot (const CRCL_Robot_optional& x)
{
  this->CRCL_Robot_ = x;
}

void robot::
CRCL_Robot (::std::auto_ptr< CRCL_Robot_type > x)
{
  this->CRCL_Robot_.set (x);
}

const robot::Mounting_optional& robot::
Mounting () const
{
  return this->Mounting_;
}

robot::Mounting_optional& robot::
Mounting ()
{
  return this->Mounting_;
}

void robot::
Mounting (const Mounting_type& x)
{
  this->Mounting_.set (x);
}

void robot::
Mounting (const Mounting_optional& x)
{
  this->Mounting_ = x;
}

void robot::
Mounting (::std::auto_ptr< Mounting_type > x)
{
  this->Mounting_.set (x);
}

const robot::ToWorld_optional& robot::
ToWorld () const
{
  return this->ToWorld_;
}

robot::ToWorld_optional& robot::
ToWorld ()
{
  return this->ToWorld_;
}

void robot::
ToWorld (const ToWorld_type& x)
{
  this->ToWorld_.set (x);
}

void robot::
ToWorld (const ToWorld_optional& x)
{
  this->ToWorld_ = x;
}

void robot::
ToWorld (::std::auto_ptr< ToWorld_type > x)
{
  this->ToWorld_.set (x);
}

const robot::Tool_sequence& robot::
Tool () const
{
  return this->Tool_;
}

robot::Tool_sequence& robot::
Tool ()
{
  return this->Tool_;
}

void robot::
Tool (const Tool_sequence& s)
{
  this->Tool_ = s;
}

const robot::link_sequence& robot::
link () const
{
  return this->link_;
}

robot::link_sequence& robot::
link ()
{
  return this->link_;
}

void robot::
link (const link_sequence& s)
{
  this->link_ = s;
}

const robot::joint_sequence& robot::
joint () const
{
  return this->joint_;
}

robot::joint_sequence& robot::
joint ()
{
  return this->joint_;
}

void robot::
joint (const joint_sequence& s)
{
  this->joint_ = s;
}

const robot::name_type& robot::
name () const
{
  return this->name_.get ();
}

robot::name_type& robot::
name ()
{
  return this->name_.get ();
}

void robot::
name (const name_type& x)
{
  this->name_.set (x);
}

void robot::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}

const robot::version_type& robot::
version () const
{
  return this->version_.get ();
}

robot::version_type& robot::
version ()
{
  return this->version_.get ();
}

void robot::
version (const version_type& x)
{
  this->version_.set (x);
}

void robot::
version (::std::auto_ptr< version_type > x)
{
  this->version_.set (x);
}

const robot::version_type& robot::
version_default_value ()
{
  return version_default_value_;
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// pose
//

const pose::xyz_type pose::xyz_default_value_ (
  "0 0 0");

const pose::rpy_type pose::rpy_default_value_ (
  "0 0 0");

pose::
pose ()
: ::xml_schema::type (),
  xyz_ (xyz_default_value (), this),
  rpy_ (rpy_default_value (), this)
{
}

pose::
pose (const pose& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  xyz_ (x.xyz_, f, this),
  rpy_ (x.rpy_, f, this)
{
}

pose::
pose (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  xyz_ (this),
  rpy_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void pose::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "xyz" && n.namespace_ ().empty ())
    {
      this->xyz_.set (xyz_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "rpy" && n.namespace_ ().empty ())
    {
      this->rpy_.set (rpy_traits::create (i, f, this));
      continue;
    }
  }

  if (!xyz_.present ())
  {
    this->xyz_.set (xyz_default_value ());
  }

  if (!rpy_.present ())
  {
    this->rpy_.set (rpy_default_value ());
  }
}

pose* pose::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class pose (*this, f, c);
}

pose& pose::
operator= (const pose& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->xyz_ = x.xyz_;
    this->rpy_ = x.rpy_;
  }

  return *this;
}

pose::
~pose ()
{
}

// color
//

const color::rgba_type color::rgba_default_value_ (
  "0 0 0 0");

color::
color ()
: ::xml_schema::type (),
  rgba_ (rgba_default_value (), this)
{
}

color::
color (const color& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  rgba_ (x.rgba_, f, this)
{
}

color::
color (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  rgba_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void color::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "rgba" && n.namespace_ ().empty ())
    {
      this->rgba_.set (rgba_traits::create (i, f, this));
      continue;
    }
  }

  if (!rgba_.present ())
  {
    this->rgba_.set (rgba_default_value ());
  }
}

color* color::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class color (*this, f, c);
}

color& color::
operator= (const color& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->rgba_ = x.rgba_;
  }

  return *this;
}

color::
~color ()
{
}

// verbose
//

verbose::
verbose ()
: ::xml_schema::type (),
  value_ (this)
{
}

verbose::
verbose (const verbose& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  value_ (x.value_, f, this)
{
}

verbose::
verbose (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  value_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void verbose::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "value" && n.namespace_ ().empty ())
    {
      this->value_.set (value_traits::create (i, f, this));
      continue;
    }
  }
}

verbose* verbose::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class verbose (*this, f, c);
}

verbose& verbose::
operator= (const verbose& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->value_ = x.value_;
  }

  return *this;
}

verbose::
~verbose ()
{
}

// name
//

name::
name ()
: ::xml_schema::type (),
  name1_ (this)
{
}

name::
name (const name& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  name1_ (x.name1_, f, this)
{
}

name::
name (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  name1_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void name::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name1_.set (name1_traits::create (i, f, this));
      continue;
    }
  }
}

name* name::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class name (*this, f, c);
}

name& name::
operator= (const name& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->name1_ = x.name1_;
  }

  return *this;
}

name::
~name ()
{
}

// mass
//

mass::
mass ()
: ::xml_schema::type (),
  value_ (value_default_value (), this)
{
}

mass::
mass (const mass& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  value_ (x.value_, f, this)
{
}

mass::
mass (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  value_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void mass::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "value" && n.namespace_ ().empty ())
    {
      this->value_.set (value_traits::create (i, f, this));
      continue;
    }
  }

  if (!value_.present ())
  {
    this->value_.set (value_default_value ());
  }
}

mass* mass::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class mass (*this, f, c);
}

mass& mass::
operator= (const mass& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->value_ = x.value_;
  }

  return *this;
}

mass::
~mass ()
{
}

// inertia
//

inertia::
inertia ()
: ::xml_schema::type (),
  ixx_ (ixx_default_value (), this),
  ixy_ (ixy_default_value (), this),
  ixz_ (ixz_default_value (), this),
  iyy_ (iyy_default_value (), this),
  iyz_ (iyz_default_value (), this),
  izz_ (izz_default_value (), this)
{
}

inertia::
inertia (const inertia& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  ixx_ (x.ixx_, f, this),
  ixy_ (x.ixy_, f, this),
  ixz_ (x.ixz_, f, this),
  iyy_ (x.iyy_, f, this),
  iyz_ (x.iyz_, f, this),
  izz_ (x.izz_, f, this)
{
}

inertia::
inertia (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  ixx_ (this),
  ixy_ (this),
  ixz_ (this),
  iyy_ (this),
  iyz_ (this),
  izz_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void inertia::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "ixx" && n.namespace_ ().empty ())
    {
      this->ixx_.set (ixx_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "ixy" && n.namespace_ ().empty ())
    {
      this->ixy_.set (ixy_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "ixz" && n.namespace_ ().empty ())
    {
      this->ixz_.set (ixz_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "iyy" && n.namespace_ ().empty ())
    {
      this->iyy_.set (iyy_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "iyz" && n.namespace_ ().empty ())
    {
      this->iyz_.set (iyz_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "izz" && n.namespace_ ().empty ())
    {
      this->izz_.set (izz_traits::create (i, f, this));
      continue;
    }
  }

  if (!ixx_.present ())
  {
    this->ixx_.set (ixx_default_value ());
  }

  if (!ixy_.present ())
  {
    this->ixy_.set (ixy_default_value ());
  }

  if (!ixz_.present ())
  {
    this->ixz_.set (ixz_default_value ());
  }

  if (!iyy_.present ())
  {
    this->iyy_.set (iyy_default_value ());
  }

  if (!iyz_.present ())
  {
    this->iyz_.set (iyz_default_value ());
  }

  if (!izz_.present ())
  {
    this->izz_.set (izz_default_value ());
  }
}

inertia* inertia::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class inertia (*this, f, c);
}

inertia& inertia::
operator= (const inertia& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->ixx_ = x.ixx_;
    this->ixy_ = x.ixy_;
    this->ixz_ = x.ixz_;
    this->iyy_ = x.iyy_;
    this->iyz_ = x.iyz_;
    this->izz_ = x.izz_;
  }

  return *this;
}

inertia::
~inertia ()
{
}

// inertial
//

inertial::
inertial ()
: ::xml_schema::type (),
  origin_ (this),
  mass_ (this),
  inertia_ (this)
{
}

inertial::
inertial (const inertial& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  origin_ (x.origin_, f, this),
  mass_ (x.mass_, f, this),
  inertia_ (x.inertia_, f, this)
{
}

inertial::
inertial (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  origin_ (this),
  mass_ (this),
  inertia_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void inertial::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // origin
    //
    if (n.name () == "origin" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< origin_type > r (
        origin_traits::create (i, f, this));

      if (!this->origin_)
      {
        this->origin_.set (r);
        continue;
      }
    }

    // mass
    //
    if (n.name () == "mass" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< mass_type > r (
        mass_traits::create (i, f, this));

      if (!this->mass_)
      {
        this->mass_.set (r);
        continue;
      }
    }

    // inertia
    //
    if (n.name () == "inertia" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< inertia_type > r (
        inertia_traits::create (i, f, this));

      if (!this->inertia_)
      {
        this->inertia_.set (r);
        continue;
      }
    }

    break;
  }
}

inertial* inertial::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class inertial (*this, f, c);
}

inertial& inertial::
operator= (const inertial& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->origin_ = x.origin_;
    this->mass_ = x.mass_;
    this->inertia_ = x.inertia_;
  }

  return *this;
}

inertial::
~inertial ()
{
}

// box
//

const box::size_type box::size_default_value_ (
  "0 0 0");

box::
box ()
: ::xml_schema::type (),
  size_ (size_default_value (), this)
{
}

box::
box (const box& x,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  size_ (x.size_, f, this)
{
}

box::
box (const ::xercesc::DOMElement& e,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  size_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void box::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "size" && n.namespace_ ().empty ())
    {
      this->size_.set (size_traits::create (i, f, this));
      continue;
    }
  }

  if (!size_.present ())
  {
    this->size_.set (size_default_value ());
  }
}

box* box::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class box (*this, f, c);
}

box& box::
operator= (const box& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->size_ = x.size_;
  }

  return *this;
}

box::
~box ()
{
}

// cylinder
//

cylinder::
cylinder (const radius_type& radius,
          const length_type& length)
: ::xml_schema::type (),
  radius_ (radius, this),
  length_ (length, this)
{
}

cylinder::
cylinder (const cylinder& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  radius_ (x.radius_, f, this),
  length_ (x.length_, f, this)
{
}

cylinder::
cylinder (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  radius_ (this),
  length_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void cylinder::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "radius" && n.namespace_ ().empty ())
    {
      this->radius_.set (radius_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "length" && n.namespace_ ().empty ())
    {
      this->length_.set (length_traits::create (i, f, this));
      continue;
    }
  }

  if (!radius_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "radius",
      "");
  }

  if (!length_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "length",
      "");
  }
}

cylinder* cylinder::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class cylinder (*this, f, c);
}

cylinder& cylinder::
operator= (const cylinder& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->radius_ = x.radius_;
    this->length_ = x.length_;
  }

  return *this;
}

cylinder::
~cylinder ()
{
}

// sphere
//

sphere::
sphere (const radius_type& radius)
: ::xml_schema::type (),
  radius_ (radius, this)
{
}

sphere::
sphere (const sphere& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  radius_ (x.radius_, f, this)
{
}

sphere::
sphere (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  radius_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void sphere::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "radius" && n.namespace_ ().empty ())
    {
      this->radius_.set (radius_traits::create (i, f, this));
      continue;
    }
  }

  if (!radius_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "radius",
      "");
  }
}

sphere* sphere::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class sphere (*this, f, c);
}

sphere& sphere::
operator= (const sphere& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->radius_ = x.radius_;
  }

  return *this;
}

sphere::
~sphere ()
{
}

// mesh
//

const mesh::scale_type mesh::scale_default_value_ (
  "1 1 1");

mesh::
mesh (const filename_type& filename)
: ::xml_schema::type (),
  filename_ (filename, this),
  scale_ (scale_default_value (), this)
{
}

mesh::
mesh (const mesh& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  filename_ (x.filename_, f, this),
  scale_ (x.scale_, f, this)
{
}

mesh::
mesh (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  filename_ (this),
  scale_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void mesh::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "filename" && n.namespace_ ().empty ())
    {
      this->filename_.set (filename_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "scale" && n.namespace_ ().empty ())
    {
      this->scale_.set (scale_traits::create (i, f, this));
      continue;
    }
  }

  if (!filename_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "filename",
      "");
  }

  if (!scale_.present ())
  {
    this->scale_.set (scale_default_value ());
  }
}

mesh* mesh::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class mesh (*this, f, c);
}

mesh& mesh::
operator= (const mesh& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->filename_ = x.filename_;
    this->scale_ = x.scale_;
  }

  return *this;
}

mesh::
~mesh ()
{
}

// geometry
//

geometry::
geometry ()
: ::xml_schema::type (),
  box_ (this),
  cylinder_ (this),
  sphere_ (this),
  mesh_ (this)
{
}

geometry::
geometry (const geometry& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  box_ (x.box_, f, this),
  cylinder_ (x.cylinder_, f, this),
  sphere_ (x.sphere_, f, this),
  mesh_ (x.mesh_, f, this)
{
}

geometry::
geometry (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  box_ (this),
  cylinder_ (this),
  sphere_ (this),
  mesh_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void geometry::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // box
    //
    if (n.name () == "box" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< box_type > r (
        box_traits::create (i, f, this));

      if (!this->box_)
      {
        this->box_.set (r);
        continue;
      }
    }

    // cylinder
    //
    if (n.name () == "cylinder" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< cylinder_type > r (
        cylinder_traits::create (i, f, this));

      if (!this->cylinder_)
      {
        this->cylinder_.set (r);
        continue;
      }
    }

    // sphere
    //
    if (n.name () == "sphere" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< sphere_type > r (
        sphere_traits::create (i, f, this));

      if (!this->sphere_)
      {
        this->sphere_.set (r);
        continue;
      }
    }

    // mesh
    //
    if (n.name () == "mesh" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< mesh_type > r (
        mesh_traits::create (i, f, this));

      if (!this->mesh_)
      {
        this->mesh_.set (r);
        continue;
      }
    }

    break;
  }
}

geometry* geometry::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class geometry (*this, f, c);
}

geometry& geometry::
operator= (const geometry& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->box_ = x.box_;
    this->cylinder_ = x.cylinder_;
    this->sphere_ = x.sphere_;
    this->mesh_ = x.mesh_;
  }

  return *this;
}

geometry::
~geometry ()
{
}

// texture
//

texture::
texture ()
: ::xml_schema::type (),
  filename_ (this)
{
}

texture::
texture (const texture& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  filename_ (x.filename_, f, this)
{
}

texture::
texture (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  filename_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void texture::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "filename" && n.namespace_ ().empty ())
    {
      this->filename_.set (filename_traits::create (i, f, this));
      continue;
    }
  }
}

texture* texture::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class texture (*this, f, c);
}

texture& texture::
operator= (const texture& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->filename_ = x.filename_;
  }

  return *this;
}

texture::
~texture ()
{
}

// material
//

material::
material ()
: ::xml_schema::type (),
  color_ (this),
  texture_ (this),
  name_ (this)
{
}

material::
material (const material& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  color_ (x.color_, f, this),
  texture_ (x.texture_, f, this),
  name_ (x.name_, f, this)
{
}

material::
material (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  color_ (this),
  texture_ (this),
  name_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void material::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // color
    //
    if (n.name () == "color" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< color_type > r (
        color_traits::create (i, f, this));

      if (!this->color_)
      {
        this->color_.set (r);
        continue;
      }
    }

    // texture
    //
    if (n.name () == "texture" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< texture_type > r (
        texture_traits::create (i, f, this));

      if (!this->texture_)
      {
        this->texture_.set (r);
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }
  }
}

material* material::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class material (*this, f, c);
}

material& material::
operator= (const material& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->color_ = x.color_;
    this->texture_ = x.texture_;
    this->name_ = x.name_;
  }

  return *this;
}

material::
~material ()
{
}

// material_global
//

material_global::
material_global (const name_type& name)
: ::xml_schema::type (),
  color_ (this),
  texture_ (this),
  name_ (name, this)
{
}

material_global::
material_global (const material_global& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  color_ (x.color_, f, this),
  texture_ (x.texture_, f, this),
  name_ (x.name_, f, this)
{
}

material_global::
material_global (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  color_ (this),
  texture_ (this),
  name_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void material_global::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // color
    //
    if (n.name () == "color" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< color_type > r (
        color_traits::create (i, f, this));

      if (!this->color_)
      {
        this->color_.set (r);
        continue;
      }
    }

    // texture
    //
    if (n.name () == "texture" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< texture_type > r (
        texture_traits::create (i, f, this));

      if (!this->texture_)
      {
        this->texture_.set (r);
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "name",
      "");
  }
}

material_global* material_global::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class material_global (*this, f, c);
}

material_global& material_global::
operator= (const material_global& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->color_ = x.color_;
    this->texture_ = x.texture_;
    this->name_ = x.name_;
  }

  return *this;
}

material_global::
~material_global ()
{
}

// visual
//

visual::
visual (const geometry_type& geometry)
: ::xml_schema::type (),
  origin_ (this),
  geometry_ (geometry, this),
  material_ (this)
{
}

visual::
visual (::std::auto_ptr< geometry_type > geometry)
: ::xml_schema::type (),
  origin_ (this),
  geometry_ (geometry, this),
  material_ (this)
{
}

visual::
visual (const visual& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  origin_ (x.origin_, f, this),
  geometry_ (x.geometry_, f, this),
  material_ (x.material_, f, this)
{
}

visual::
visual (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  origin_ (this),
  geometry_ (this),
  material_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void visual::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // origin
    //
    if (n.name () == "origin" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< origin_type > r (
        origin_traits::create (i, f, this));

      if (!this->origin_)
      {
        this->origin_.set (r);
        continue;
      }
    }

    // geometry
    //
    if (n.name () == "geometry" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< geometry_type > r (
        geometry_traits::create (i, f, this));

      if (!geometry_.present ())
      {
        this->geometry_.set (r);
        continue;
      }
    }

    // material
    //
    if (n.name () == "material" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< material_type > r (
        material_traits::create (i, f, this));

      if (!this->material_)
      {
        this->material_.set (r);
        continue;
      }
    }

    break;
  }

  if (!geometry_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "geometry",
      "");
  }
}

visual* visual::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class visual (*this, f, c);
}

visual& visual::
operator= (const visual& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->origin_ = x.origin_;
    this->geometry_ = x.geometry_;
    this->material_ = x.material_;
  }

  return *this;
}

visual::
~visual ()
{
}

// collision
//

collision::
collision (const geometry_type& geometry)
: ::xml_schema::type (),
  origin_ (this),
  geometry_ (geometry, this),
  verbose_ (this),
  name_ (this)
{
}

collision::
collision (::std::auto_ptr< geometry_type > geometry)
: ::xml_schema::type (),
  origin_ (this),
  geometry_ (geometry, this),
  verbose_ (this),
  name_ (this)
{
}

collision::
collision (const collision& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  origin_ (x.origin_, f, this),
  geometry_ (x.geometry_, f, this),
  verbose_ (x.verbose_, f, this),
  name_ (x.name_, f, this)
{
}

collision::
collision (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  origin_ (this),
  geometry_ (this),
  verbose_ (this),
  name_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void collision::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // origin
    //
    if (n.name () == "origin" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< origin_type > r (
        origin_traits::create (i, f, this));

      if (!this->origin_)
      {
        this->origin_.set (r);
        continue;
      }
    }

    // geometry
    //
    if (n.name () == "geometry" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< geometry_type > r (
        geometry_traits::create (i, f, this));

      if (!geometry_.present ())
      {
        this->geometry_.set (r);
        continue;
      }
    }

    // verbose
    //
    if (n.name () == "verbose" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< verbose_type > r (
        verbose_traits::create (i, f, this));

      if (!this->verbose_)
      {
        this->verbose_.set (r);
        continue;
      }
    }

    break;
  }

  if (!geometry_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "geometry",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }
  }
}

collision* collision::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class collision (*this, f, c);
}

collision& collision::
operator= (const collision& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->origin_ = x.origin_;
    this->geometry_ = x.geometry_;
    this->verbose_ = x.verbose_;
    this->name_ = x.name_;
  }

  return *this;
}

collision::
~collision ()
{
}

// link
//

link::
link (const name_type& name)
: ::xml_schema::type (),
  inertial_ (this),
  visual_ (this),
  collision_ (this),
  name_ (name, this),
  type_ (this)
{
}

link::
link (const link& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  inertial_ (x.inertial_, f, this),
  visual_ (x.visual_, f, this),
  collision_ (x.collision_, f, this),
  name_ (x.name_, f, this),
  type_ (x.type_, f, this)
{
}

link::
link (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  inertial_ (this),
  visual_ (this),
  collision_ (this),
  name_ (this),
  type_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void link::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // inertial
    //
    if (n.name () == "inertial" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< inertial_type > r (
        inertial_traits::create (i, f, this));

      if (!this->inertial_)
      {
        this->inertial_.set (r);
        continue;
      }
    }

    // visual
    //
    if (n.name () == "visual" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< visual_type > r (
        visual_traits::create (i, f, this));

      if (!this->visual_)
      {
        this->visual_.set (r);
        continue;
      }
    }

    // collision
    //
    if (n.name () == "collision" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< collision_type > r (
        collision_traits::create (i, f, this));

      if (!this->collision_)
      {
        this->collision_.set (r);
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type_.set (type_traits::create (i, f, this));
      continue;
    }
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "name",
      "");
  }
}

link* link::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class link (*this, f, c);
}

link& link::
operator= (const link& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->inertial_ = x.inertial_;
    this->visual_ = x.visual_;
    this->collision_ = x.collision_;
    this->name_ = x.name_;
    this->type_ = x.type_;
  }

  return *this;
}

link::
~link ()
{
}

// parent
//

parent::
parent (const link_type& link)
: ::xml_schema::type (),
  link_ (link, this)
{
}

parent::
parent (const parent& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  link_ (x.link_, f, this)
{
}

parent::
parent (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  link_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void parent::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "link" && n.namespace_ ().empty ())
    {
      this->link_.set (link_traits::create (i, f, this));
      continue;
    }
  }

  if (!link_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "link",
      "");
  }
}

parent* parent::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class parent (*this, f, c);
}

parent& parent::
operator= (const parent& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->link_ = x.link_;
  }

  return *this;
}

parent::
~parent ()
{
}

// child
//

child::
child (const link_type& link)
: ::xml_schema::type (),
  link_ (link, this)
{
}

child::
child (const child& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  link_ (x.link_, f, this)
{
}

child::
child (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  link_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void child::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "link" && n.namespace_ ().empty ())
    {
      this->link_.set (link_traits::create (i, f, this));
      continue;
    }
  }

  if (!link_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "link",
      "");
  }
}

child* child::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class child (*this, f, c);
}

child& child::
operator= (const child& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->link_ = x.link_;
  }

  return *this;
}

child::
~child ()
{
}

// axis
//

const axis::xyz_type axis::xyz_default_value_ (
  "1 0 0");

axis::
axis ()
: ::xml_schema::type (),
  xyz_ (xyz_default_value (), this)
{
}

axis::
axis (const axis& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  xyz_ (x.xyz_, f, this)
{
}

axis::
axis (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  xyz_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void axis::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "xyz" && n.namespace_ ().empty ())
    {
      this->xyz_.set (xyz_traits::create (i, f, this));
      continue;
    }
  }

  if (!xyz_.present ())
  {
    this->xyz_.set (xyz_default_value ());
  }
}

axis* axis::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class axis (*this, f, c);
}

axis& axis::
operator= (const axis& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->xyz_ = x.xyz_;
  }

  return *this;
}

axis::
~axis ()
{
}

// calibration
//

calibration::
calibration ()
: ::xml_schema::type (),
  reference_position_ (this),
  rising_ (this),
  falling_ (this)
{
}

calibration::
calibration (const calibration& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  reference_position_ (x.reference_position_, f, this),
  rising_ (x.rising_, f, this),
  falling_ (x.falling_, f, this)
{
}

calibration::
calibration (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  reference_position_ (this),
  rising_ (this),
  falling_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void calibration::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "reference_position" && n.namespace_ ().empty ())
    {
      this->reference_position_.set (reference_position_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "rising" && n.namespace_ ().empty ())
    {
      this->rising_.set (rising_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "falling" && n.namespace_ ().empty ())
    {
      this->falling_.set (falling_traits::create (i, f, this));
      continue;
    }
  }
}

calibration* calibration::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class calibration (*this, f, c);
}

calibration& calibration::
operator= (const calibration& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->reference_position_ = x.reference_position_;
    this->rising_ = x.rising_;
    this->falling_ = x.falling_;
  }

  return *this;
}

calibration::
~calibration ()
{
}

// dynamics
//

dynamics::
dynamics ()
: ::xml_schema::type (),
  damping_ (damping_default_value (), this),
  friction_ (friction_default_value (), this)
{
}

dynamics::
dynamics (const dynamics& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  damping_ (x.damping_, f, this),
  friction_ (x.friction_, f, this)
{
}

dynamics::
dynamics (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  damping_ (this),
  friction_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void dynamics::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "damping" && n.namespace_ ().empty ())
    {
      this->damping_.set (damping_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "friction" && n.namespace_ ().empty ())
    {
      this->friction_.set (friction_traits::create (i, f, this));
      continue;
    }
  }

  if (!damping_.present ())
  {
    this->damping_.set (damping_default_value ());
  }

  if (!friction_.present ())
  {
    this->friction_.set (friction_default_value ());
  }
}

dynamics* dynamics::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class dynamics (*this, f, c);
}

dynamics& dynamics::
operator= (const dynamics& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->damping_ = x.damping_;
    this->friction_ = x.friction_;
  }

  return *this;
}

dynamics::
~dynamics ()
{
}

// limit
//

limit::
limit ()
: ::xml_schema::type (),
  lower_ (lower_default_value (), this),
  upper_ (upper_default_value (), this),
  effort_ (effort_default_value (), this),
  velocity_ (velocity_default_value (), this)
{
}

limit::
limit (const limit& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  lower_ (x.lower_, f, this),
  upper_ (x.upper_, f, this),
  effort_ (x.effort_, f, this),
  velocity_ (x.velocity_, f, this)
{
}

limit::
limit (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  lower_ (this),
  upper_ (this),
  effort_ (this),
  velocity_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void limit::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "lower" && n.namespace_ ().empty ())
    {
      this->lower_.set (lower_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "upper" && n.namespace_ ().empty ())
    {
      this->upper_.set (upper_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "effort" && n.namespace_ ().empty ())
    {
      this->effort_.set (effort_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "velocity" && n.namespace_ ().empty ())
    {
      this->velocity_.set (velocity_traits::create (i, f, this));
      continue;
    }
  }

  if (!lower_.present ())
  {
    this->lower_.set (lower_default_value ());
  }

  if (!upper_.present ())
  {
    this->upper_.set (upper_default_value ());
  }

  if (!effort_.present ())
  {
    this->effort_.set (effort_default_value ());
  }

  if (!velocity_.present ())
  {
    this->velocity_.set (velocity_default_value ());
  }
}

limit* limit::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class limit (*this, f, c);
}

limit& limit::
operator= (const limit& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->lower_ = x.lower_;
    this->upper_ = x.upper_;
    this->effort_ = x.effort_;
    this->velocity_ = x.velocity_;
  }

  return *this;
}

limit::
~limit ()
{
}

// safety_controller
//

safety_controller::
safety_controller (const k_velocity_type& k_velocity)
: ::xml_schema::type (),
  soft_lower_limit_ (soft_lower_limit_default_value (), this),
  soft_upper_limit_ (soft_upper_limit_default_value (), this),
  k_position_ (k_position_default_value (), this),
  k_velocity_ (k_velocity, this)
{
}

safety_controller::
safety_controller (const safety_controller& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  soft_lower_limit_ (x.soft_lower_limit_, f, this),
  soft_upper_limit_ (x.soft_upper_limit_, f, this),
  k_position_ (x.k_position_, f, this),
  k_velocity_ (x.k_velocity_, f, this)
{
}

safety_controller::
safety_controller (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  soft_lower_limit_ (this),
  soft_upper_limit_ (this),
  k_position_ (this),
  k_velocity_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void safety_controller::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "soft_lower_limit" && n.namespace_ ().empty ())
    {
      this->soft_lower_limit_.set (soft_lower_limit_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "soft_upper_limit" && n.namespace_ ().empty ())
    {
      this->soft_upper_limit_.set (soft_upper_limit_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "k_position" && n.namespace_ ().empty ())
    {
      this->k_position_.set (k_position_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "k_velocity" && n.namespace_ ().empty ())
    {
      this->k_velocity_.set (k_velocity_traits::create (i, f, this));
      continue;
    }
  }

  if (!soft_lower_limit_.present ())
  {
    this->soft_lower_limit_.set (soft_lower_limit_default_value ());
  }

  if (!soft_upper_limit_.present ())
  {
    this->soft_upper_limit_.set (soft_upper_limit_default_value ());
  }

  if (!k_position_.present ())
  {
    this->k_position_.set (k_position_default_value ());
  }

  if (!k_velocity_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "k_velocity",
      "");
  }
}

safety_controller* safety_controller::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class safety_controller (*this, f, c);
}

safety_controller& safety_controller::
operator= (const safety_controller& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->soft_lower_limit_ = x.soft_lower_limit_;
    this->soft_upper_limit_ = x.soft_upper_limit_;
    this->k_position_ = x.k_position_;
    this->k_velocity_ = x.k_velocity_;
  }

  return *this;
}

safety_controller::
~safety_controller ()
{
}

// mimic
//

mimic::
mimic (const joint_type& joint)
: ::xml_schema::type (),
  joint_ (joint, this),
  multiplier_ (multiplier_default_value (), this),
  offset_ (offset_default_value (), this)
{
}

mimic::
mimic (const mimic& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  joint_ (x.joint_, f, this),
  multiplier_ (x.multiplier_, f, this),
  offset_ (x.offset_, f, this)
{
}

mimic::
mimic (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  joint_ (this),
  multiplier_ (this),
  offset_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void mimic::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "joint" && n.namespace_ ().empty ())
    {
      this->joint_.set (joint_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "multiplier" && n.namespace_ ().empty ())
    {
      this->multiplier_.set (multiplier_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "offset" && n.namespace_ ().empty ())
    {
      this->offset_.set (offset_traits::create (i, f, this));
      continue;
    }
  }

  if (!joint_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "joint",
      "");
  }

  if (!multiplier_.present ())
  {
    this->multiplier_.set (multiplier_default_value ());
  }

  if (!offset_.present ())
  {
    this->offset_.set (offset_default_value ());
  }
}

mimic* mimic::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class mimic (*this, f, c);
}

mimic& mimic::
operator= (const mimic& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->joint_ = x.joint_;
    this->multiplier_ = x.multiplier_;
    this->offset_ = x.offset_;
  }

  return *this;
}

mimic::
~mimic ()
{
}

// actuator_transmission
//

actuator_transmission::
actuator_transmission (const mechanicalReduction_type& mechanicalReduction,
                       const name_type& name)
: ::xml_schema::type (),
  mechanicalReduction_ (mechanicalReduction, this),
  name_ (name, this)
{
}

actuator_transmission::
actuator_transmission (const actuator_transmission& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  mechanicalReduction_ (x.mechanicalReduction_, f, this),
  name_ (x.name_, f, this)
{
}

actuator_transmission::
actuator_transmission (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  mechanicalReduction_ (this),
  name_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void actuator_transmission::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "mechanicalReduction" && n.namespace_ ().empty ())
    {
      this->mechanicalReduction_.set (mechanicalReduction_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }
  }

  if (!mechanicalReduction_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "mechanicalReduction",
      "");
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "name",
      "");
  }
}

actuator_transmission* actuator_transmission::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class actuator_transmission (*this, f, c);
}

actuator_transmission& actuator_transmission::
operator= (const actuator_transmission& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->mechanicalReduction_ = x.mechanicalReduction_;
    this->name_ = x.name_;
  }

  return *this;
}

actuator_transmission::
~actuator_transmission ()
{
}

// gap_joint_transmission
//

gap_joint_transmission::
gap_joint_transmission (const L0_type& L0,
                        const a_type& a,
                        const b_type& b,
                        const gear_ratio_type& gear_ratio,
                        const h_type& h,
                        const mechanical_reduction_type& mechanical_reduction,
                        const name_type& name,
                        const phi0_type& phi0,
                        const r_type& r,
                        const screw_reduction_type& screw_reduction,
                        const t0_type& t0,
                        const theta0_type& theta0)
: ::xml_schema::type (),
  L0_ (L0, this),
  a_ (a, this),
  b_ (b, this),
  gear_ratio_ (gear_ratio, this),
  h_ (h, this),
  mechanical_reduction_ (mechanical_reduction, this),
  name_ (name, this),
  phi0_ (phi0, this),
  r_ (r, this),
  screw_reduction_ (screw_reduction, this),
  t0_ (t0, this),
  theta0_ (theta0, this)
{
}

gap_joint_transmission::
gap_joint_transmission (const gap_joint_transmission& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  L0_ (x.L0_, f, this),
  a_ (x.a_, f, this),
  b_ (x.b_, f, this),
  gear_ratio_ (x.gear_ratio_, f, this),
  h_ (x.h_, f, this),
  mechanical_reduction_ (x.mechanical_reduction_, f, this),
  name_ (x.name_, f, this),
  phi0_ (x.phi0_, f, this),
  r_ (x.r_, f, this),
  screw_reduction_ (x.screw_reduction_, f, this),
  t0_ (x.t0_, f, this),
  theta0_ (x.theta0_, f, this)
{
}

gap_joint_transmission::
gap_joint_transmission (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  L0_ (this),
  a_ (this),
  b_ (this),
  gear_ratio_ (this),
  h_ (this),
  mechanical_reduction_ (this),
  name_ (this),
  phi0_ (this),
  r_ (this),
  screw_reduction_ (this),
  t0_ (this),
  theta0_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void gap_joint_transmission::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "L0" && n.namespace_ ().empty ())
    {
      this->L0_.set (L0_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "a" && n.namespace_ ().empty ())
    {
      this->a_.set (a_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "b" && n.namespace_ ().empty ())
    {
      this->b_.set (b_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "gear_ratio" && n.namespace_ ().empty ())
    {
      this->gear_ratio_.set (gear_ratio_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "h" && n.namespace_ ().empty ())
    {
      this->h_.set (h_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "mechanical_reduction" && n.namespace_ ().empty ())
    {
      this->mechanical_reduction_.set (mechanical_reduction_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "phi0" && n.namespace_ ().empty ())
    {
      this->phi0_.set (phi0_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "r" && n.namespace_ ().empty ())
    {
      this->r_.set (r_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "screw_reduction" && n.namespace_ ().empty ())
    {
      this->screw_reduction_.set (screw_reduction_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "t0" && n.namespace_ ().empty ())
    {
      this->t0_.set (t0_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "theta0" && n.namespace_ ().empty ())
    {
      this->theta0_.set (theta0_traits::create (i, f, this));
      continue;
    }
  }

  if (!L0_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "L0",
      "");
  }

  if (!a_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "a",
      "");
  }

  if (!b_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "b",
      "");
  }

  if (!gear_ratio_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "gear_ratio",
      "");
  }

  if (!h_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "h",
      "");
  }

  if (!mechanical_reduction_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "mechanical_reduction",
      "");
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "name",
      "");
  }

  if (!phi0_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "phi0",
      "");
  }

  if (!r_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "r",
      "");
  }

  if (!screw_reduction_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "screw_reduction",
      "");
  }

  if (!t0_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "t0",
      "");
  }

  if (!theta0_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "theta0",
      "");
  }
}

gap_joint_transmission* gap_joint_transmission::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class gap_joint_transmission (*this, f, c);
}

gap_joint_transmission& gap_joint_transmission::
operator= (const gap_joint_transmission& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->L0_ = x.L0_;
    this->a_ = x.a_;
    this->b_ = x.b_;
    this->gear_ratio_ = x.gear_ratio_;
    this->h_ = x.h_;
    this->mechanical_reduction_ = x.mechanical_reduction_;
    this->name_ = x.name_;
    this->phi0_ = x.phi0_;
    this->r_ = x.r_;
    this->screw_reduction_ = x.screw_reduction_;
    this->t0_ = x.t0_;
    this->theta0_ = x.theta0_;
  }

  return *this;
}

gap_joint_transmission::
~gap_joint_transmission ()
{
}

// passive_joint_transmission
//

passive_joint_transmission::
passive_joint_transmission (const name_type& name)
: ::xml_schema::type (),
  name_ (name, this)
{
}

passive_joint_transmission::
passive_joint_transmission (const passive_joint_transmission& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  name_ (x.name_, f, this)
{
}

passive_joint_transmission::
passive_joint_transmission (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  name_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void passive_joint_transmission::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "name",
      "");
  }
}

passive_joint_transmission* passive_joint_transmission::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class passive_joint_transmission (*this, f, c);
}

passive_joint_transmission& passive_joint_transmission::
operator= (const passive_joint_transmission& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->name_ = x.name_;
  }

  return *this;
}

passive_joint_transmission::
~passive_joint_transmission ()
{
}

// transmission
//

transmission::
transmission (const name_type& name,
              const type_type& type)
: ::xml_schema::type (),
  leftActuator_ (this),
  rightActuator_ (this),
  flexJoint_ (this),
  rollJoint_ (this),
  gap_joint_ (this),
  passive_joint_ (this),
  use_simulated_gripper_joint_ (this),
  mechanicalReduction_ (this),
  actuator_ (this),
  joint_ (this),
  name_ (name, this),
  type_ (type, this)
{
}

transmission::
transmission (const transmission& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  leftActuator_ (x.leftActuator_, f, this),
  rightActuator_ (x.rightActuator_, f, this),
  flexJoint_ (x.flexJoint_, f, this),
  rollJoint_ (x.rollJoint_, f, this),
  gap_joint_ (x.gap_joint_, f, this),
  passive_joint_ (x.passive_joint_, f, this),
  use_simulated_gripper_joint_ (x.use_simulated_gripper_joint_, f, this),
  mechanicalReduction_ (x.mechanicalReduction_, f, this),
  actuator_ (x.actuator_, f, this),
  joint_ (x.joint_, f, this),
  name_ (x.name_, f, this),
  type_ (x.type_, f, this)
{
}

transmission::
transmission (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  leftActuator_ (this),
  rightActuator_ (this),
  flexJoint_ (this),
  rollJoint_ (this),
  gap_joint_ (this),
  passive_joint_ (this),
  use_simulated_gripper_joint_ (this),
  mechanicalReduction_ (this),
  actuator_ (this),
  joint_ (this),
  name_ (this),
  type_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void transmission::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // leftActuator
    //
    if (n.name () == "leftActuator" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< leftActuator_type > r (
        leftActuator_traits::create (i, f, this));

      this->leftActuator_.push_back (r);
      continue;
    }

    // rightActuator
    //
    if (n.name () == "rightActuator" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< rightActuator_type > r (
        rightActuator_traits::create (i, f, this));

      this->rightActuator_.push_back (r);
      continue;
    }

    // flexJoint
    //
    if (n.name () == "flexJoint" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< flexJoint_type > r (
        flexJoint_traits::create (i, f, this));

      this->flexJoint_.push_back (r);
      continue;
    }

    // rollJoint
    //
    if (n.name () == "rollJoint" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< rollJoint_type > r (
        rollJoint_traits::create (i, f, this));

      this->rollJoint_.push_back (r);
      continue;
    }

    // gap_joint
    //
    if (n.name () == "gap_joint" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< gap_joint_type > r (
        gap_joint_traits::create (i, f, this));

      this->gap_joint_.push_back (r);
      continue;
    }

    // passive_joint
    //
    if (n.name () == "passive_joint" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< passive_joint_type > r (
        passive_joint_traits::create (i, f, this));

      this->passive_joint_.push_back (r);
      continue;
    }

    // use_simulated_gripper_joint
    //
    if (n.name () == "use_simulated_gripper_joint" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< use_simulated_gripper_joint_type > r (
        use_simulated_gripper_joint_traits::create (i, f, this));

      this->use_simulated_gripper_joint_.push_back (r);
      continue;
    }

    // mechanicalReduction
    //
    if (n.name () == "mechanicalReduction" && n.namespace_ ().empty ())
    {
      this->mechanicalReduction_.push_back (mechanicalReduction_traits::create (i, f, this));
      continue;
    }

    // actuator
    //
    if (n.name () == "actuator" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< actuator_type > r (
        actuator_traits::create (i, f, this));

      this->actuator_.push_back (r);
      continue;
    }

    // joint
    //
    if (n.name () == "joint" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< joint_type > r (
        joint_traits::create (i, f, this));

      this->joint_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type_.set (type_traits::create (i, f, this));
      continue;
    }
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "name",
      "");
  }

  if (!type_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "type",
      "");
  }
}

transmission* transmission::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class transmission (*this, f, c);
}

transmission& transmission::
operator= (const transmission& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->leftActuator_ = x.leftActuator_;
    this->rightActuator_ = x.rightActuator_;
    this->flexJoint_ = x.flexJoint_;
    this->rollJoint_ = x.rollJoint_;
    this->gap_joint_ = x.gap_joint_;
    this->passive_joint_ = x.passive_joint_;
    this->use_simulated_gripper_joint_ = x.use_simulated_gripper_joint_;
    this->mechanicalReduction_ = x.mechanicalReduction_;
    this->actuator_ = x.actuator_;
    this->joint_ = x.joint_;
    this->name_ = x.name_;
    this->type_ = x.type_;
  }

  return *this;
}

transmission::
~transmission ()
{
}

// joint
//

joint::
joint (const parent_type& parent,
       const child_type& child,
       const name_type& name,
       const type_type& type)
: ::xml_schema::type (),
  origin_ (this),
  parent_ (parent, this),
  child_ (child, this),
  axis_ (this),
  calibration_ (this),
  dynamics_ (this),
  limit_ (this),
  safety_controller_ (this),
  mimic_ (this),
  name_ (name, this),
  type_ (type, this)
{
}

joint::
joint (::std::auto_ptr< parent_type > parent,
       ::std::auto_ptr< child_type > child,
       const name_type& name,
       const type_type& type)
: ::xml_schema::type (),
  origin_ (this),
  parent_ (parent, this),
  child_ (child, this),
  axis_ (this),
  calibration_ (this),
  dynamics_ (this),
  limit_ (this),
  safety_controller_ (this),
  mimic_ (this),
  name_ (name, this),
  type_ (type, this)
{
}

joint::
joint (const joint& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  origin_ (x.origin_, f, this),
  parent_ (x.parent_, f, this),
  child_ (x.child_, f, this),
  axis_ (x.axis_, f, this),
  calibration_ (x.calibration_, f, this),
  dynamics_ (x.dynamics_, f, this),
  limit_ (x.limit_, f, this),
  safety_controller_ (x.safety_controller_, f, this),
  mimic_ (x.mimic_, f, this),
  name_ (x.name_, f, this),
  type_ (x.type_, f, this)
{
}

joint::
joint (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  origin_ (this),
  parent_ (this),
  child_ (this),
  axis_ (this),
  calibration_ (this),
  dynamics_ (this),
  limit_ (this),
  safety_controller_ (this),
  mimic_ (this),
  name_ (this),
  type_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void joint::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // origin
    //
    if (n.name () == "origin" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< origin_type > r (
        origin_traits::create (i, f, this));

      if (!this->origin_)
      {
        this->origin_.set (r);
        continue;
      }
    }

    // parent
    //
    if (n.name () == "parent" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< parent_type > r (
        parent_traits::create (i, f, this));

      if (!parent_.present ())
      {
        this->parent_.set (r);
        continue;
      }
    }

    // child
    //
    if (n.name () == "child" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< child_type > r (
        child_traits::create (i, f, this));

      if (!child_.present ())
      {
        this->child_.set (r);
        continue;
      }
    }

    // axis
    //
    if (n.name () == "axis" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< axis_type > r (
        axis_traits::create (i, f, this));

      if (!this->axis_)
      {
        this->axis_.set (r);
        continue;
      }
    }

    // calibration
    //
    if (n.name () == "calibration" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< calibration_type > r (
        calibration_traits::create (i, f, this));

      if (!this->calibration_)
      {
        this->calibration_.set (r);
        continue;
      }
    }

    // dynamics
    //
    if (n.name () == "dynamics" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< dynamics_type > r (
        dynamics_traits::create (i, f, this));

      if (!this->dynamics_)
      {
        this->dynamics_.set (r);
        continue;
      }
    }

    // limit
    //
    if (n.name () == "limit" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< limit_type > r (
        limit_traits::create (i, f, this));

      if (!this->limit_)
      {
        this->limit_.set (r);
        continue;
      }
    }

    // safety_controller
    //
    if (n.name () == "safety_controller" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< safety_controller_type > r (
        safety_controller_traits::create (i, f, this));

      if (!this->safety_controller_)
      {
        this->safety_controller_.set (r);
        continue;
      }
    }

    // mimic
    //
    if (n.name () == "mimic" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< mimic_type > r (
        mimic_traits::create (i, f, this));

      if (!this->mimic_)
      {
        this->mimic_.set (r);
        continue;
      }
    }

    break;
  }

  if (!parent_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "parent",
      "");
  }

  if (!child_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "child",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type_.set (type_traits::create (i, f, this));
      continue;
    }
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "name",
      "");
  }

  if (!type_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "type",
      "");
  }
}

joint* joint::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class joint (*this, f, c);
}

joint& joint::
operator= (const joint& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->origin_ = x.origin_;
    this->parent_ = x.parent_;
    this->child_ = x.child_;
    this->axis_ = x.axis_;
    this->calibration_ = x.calibration_;
    this->dynamics_ = x.dynamics_;
    this->limit_ = x.limit_;
    this->safety_controller_ = x.safety_controller_;
    this->mimic_ = x.mimic_;
    this->name_ = x.name_;
    this->type_ = x.type_;
  }

  return *this;
}

joint::
~joint ()
{
}

// Debug
//

Debug::
Debug (const ::xml_schema::boolean& _xsd_boolean_base)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::boolean, char, ::xml_schema::simple_type > (_xsd_boolean_base)
{
}

Debug::
Debug (const Debug& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::boolean, char, ::xml_schema::simple_type > (x, f, c)
{
}

Debug::
Debug (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::boolean, char, ::xml_schema::simple_type > (e, f, c)
{
}

Debug::
Debug (const ::xercesc::DOMAttr& a,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::boolean, char, ::xml_schema::simple_type > (a, f, c)
{
}

Debug::
Debug (const ::std::string& s,
       const ::xercesc::DOMElement* e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::boolean, char, ::xml_schema::simple_type > (s, e, f, c)
{
}

Debug* Debug::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Debug (*this, f, c);
}

Debug::
~Debug ()
{
}

// CrpiType
//

CrpiType::
CrpiType ()
: ::xml_schema::string ()
{
}

CrpiType::
CrpiType (const char* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base)
{
}

CrpiType::
CrpiType (const ::std::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base)
{
}

CrpiType::
CrpiType (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base)
{
}

CrpiType::
CrpiType (const CrpiType& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (x, f, c)
{
}

CrpiType::
CrpiType (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
}

CrpiType::
CrpiType (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
}

CrpiType::
CrpiType (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
}

CrpiType* CrpiType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class CrpiType (*this, f, c);
}

CrpiType::
~CrpiType ()
{
}

// TCP_IP
//

TCP_IP::
TCP_IP (const Address_type& Address,
        const Port_type& Port,
        const Client_type& Client)
: ::xml_schema::type (),
  Address_ (Address, this),
  Port_ (Port, this),
  Client_ (Client, this)
{
}

TCP_IP::
TCP_IP (const TCP_IP& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Address_ (x.Address_, f, this),
  Port_ (x.Port_, f, this),
  Client_ (x.Client_, f, this)
{
}

TCP_IP::
TCP_IP (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Address_ (this),
  Port_ (this),
  Client_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void TCP_IP::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Address" && n.namespace_ ().empty ())
    {
      this->Address_.set (Address_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Port" && n.namespace_ ().empty ())
    {
      this->Port_.set (Port_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Client" && n.namespace_ ().empty ())
    {
      this->Client_.set (Client_traits::create (i, f, this));
      continue;
    }
  }

  if (!Address_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "Address",
      "");
  }

  if (!Port_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "Port",
      "");
  }

  if (!Client_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "Client",
      "");
  }
}

TCP_IP* TCP_IP::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class TCP_IP (*this, f, c);
}

TCP_IP& TCP_IP::
operator= (const TCP_IP& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Address_ = x.Address_;
    this->Port_ = x.Port_;
    this->Client_ = x.Client_;
  }

  return *this;
}

TCP_IP::
~TCP_IP ()
{
}

// ComType
//

ComType::
ComType (const Val_type& Val)
: ::xml_schema::type (),
  Val_ (Val, this)
{
}

ComType::
ComType (const ComType& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Val_ (x.Val_, f, this)
{
}

ComType::
ComType (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Val_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void ComType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Val" && n.namespace_ ().empty ())
    {
      this->Val_.set (Val_traits::create (i, f, this));
      continue;
    }
  }

  if (!Val_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "Val",
      "");
  }
}

ComType* ComType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ComType (*this, f, c);
}

ComType& ComType::
operator= (const ComType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Val_ = x.Val_;
  }

  return *this;
}

ComType::
~ComType ()
{
}

// CRCL_Robot
//

CRCL_Robot::
CRCL_Robot ()
: ::xml_schema::type (),
  Status_Request_Period_ (this),
  Command_Schema_ (this),
  Status_Schema_ (this)
{
}

CRCL_Robot::
CRCL_Robot (const CRCL_Robot& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Status_Request_Period_ (x.Status_Request_Period_, f, this),
  Command_Schema_ (x.Command_Schema_, f, this),
  Status_Schema_ (x.Status_Schema_, f, this)
{
}

CRCL_Robot::
CRCL_Robot (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Status_Request_Period_ (this),
  Command_Schema_ (this),
  Status_Schema_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void CRCL_Robot::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Status_Request_Period
    //
    if (n.name () == "Status_Request_Period" && n.namespace_ ().empty ())
    {
      if (!this->Status_Request_Period_)
      {
        this->Status_Request_Period_.set (Status_Request_Period_traits::create (i, f, this));
        continue;
      }
    }

    // Command_Schema
    //
    if (n.name () == "Command_Schema" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Command_Schema_type > r (
        Command_Schema_traits::create (i, f, this));

      if (!this->Command_Schema_)
      {
        this->Command_Schema_.set (r);
        continue;
      }
    }

    // Status_Schema
    //
    if (n.name () == "Status_Schema" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Status_Schema_type > r (
        Status_Schema_traits::create (i, f, this));

      if (!this->Status_Schema_)
      {
        this->Status_Schema_.set (r);
        continue;
      }
    }

    break;
  }
}

CRCL_Robot* CRCL_Robot::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class CRCL_Robot (*this, f, c);
}

CRCL_Robot& CRCL_Robot::
operator= (const CRCL_Robot& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Status_Request_Period_ = x.Status_Request_Period_;
    this->Command_Schema_ = x.Command_Schema_;
    this->Status_Schema_ = x.Status_Schema_;
  }

  return *this;
}

CRCL_Robot::
~CRCL_Robot ()
{
}

// Mounting
//

Mounting::
Mounting (const X_type& X,
          const Y_type& Y,
          const Z_type& Z,
          const XR_type& XR,
          const YR_type& YR,
          const ZR_type& ZR)
: ::xml_schema::type (),
  X_ (X, this),
  Y_ (Y, this),
  Z_ (Z, this),
  XR_ (XR, this),
  YR_ (YR, this),
  ZR_ (ZR, this)
{
}

Mounting::
Mounting (const Mounting& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  X_ (x.X_, f, this),
  Y_ (x.Y_, f, this),
  Z_ (x.Z_, f, this),
  XR_ (x.XR_, f, this),
  YR_ (x.YR_, f, this),
  ZR_ (x.ZR_, f, this)
{
}

Mounting::
Mounting (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  X_ (this),
  Y_ (this),
  Z_ (this),
  XR_ (this),
  YR_ (this),
  ZR_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void Mounting::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "X" && n.namespace_ ().empty ())
    {
      this->X_.set (X_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Y" && n.namespace_ ().empty ())
    {
      this->Y_.set (Y_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Z" && n.namespace_ ().empty ())
    {
      this->Z_.set (Z_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "XR" && n.namespace_ ().empty ())
    {
      this->XR_.set (XR_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "YR" && n.namespace_ ().empty ())
    {
      this->YR_.set (YR_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "ZR" && n.namespace_ ().empty ())
    {
      this->ZR_.set (ZR_traits::create (i, f, this));
      continue;
    }
  }

  if (!X_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "X",
      "");
  }

  if (!Y_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "Y",
      "");
  }

  if (!Z_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "Z",
      "");
  }

  if (!XR_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "XR",
      "");
  }

  if (!YR_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "YR",
      "");
  }

  if (!ZR_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "ZR",
      "");
  }
}

Mounting* Mounting::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Mounting (*this, f, c);
}

Mounting& Mounting::
operator= (const Mounting& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->X_ = x.X_;
    this->Y_ = x.Y_;
    this->Z_ = x.Z_;
    this->XR_ = x.XR_;
    this->YR_ = x.YR_;
    this->ZR_ = x.ZR_;
  }

  return *this;
}

Mounting::
~Mounting ()
{
}

// ToWorld
//

ToWorld::
ToWorld (const X_type& X,
         const Y_type& Y,
         const Z_type& Z,
         const XR_type& XR,
         const YR_type& YR,
         const ZR_type& ZR)
: ::xml_schema::type (),
  X_ (X, this),
  Y_ (Y, this),
  Z_ (Z, this),
  XR_ (XR, this),
  YR_ (YR, this),
  ZR_ (ZR, this),
  M00_ (this),
  M01_ (this),
  M02_ (this),
  M03_ (this),
  M10_ (this),
  M11_ (this),
  M12_ (this),
  M13_ (this),
  M20_ (this),
  M21_ (this),
  M22_ (this),
  M23_ (this),
  M30_ (this),
  M31_ (this),
  M32_ (this),
  M33_ (this)
{
}

ToWorld::
ToWorld (const ToWorld& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  X_ (x.X_, f, this),
  Y_ (x.Y_, f, this),
  Z_ (x.Z_, f, this),
  XR_ (x.XR_, f, this),
  YR_ (x.YR_, f, this),
  ZR_ (x.ZR_, f, this),
  M00_ (x.M00_, f, this),
  M01_ (x.M01_, f, this),
  M02_ (x.M02_, f, this),
  M03_ (x.M03_, f, this),
  M10_ (x.M10_, f, this),
  M11_ (x.M11_, f, this),
  M12_ (x.M12_, f, this),
  M13_ (x.M13_, f, this),
  M20_ (x.M20_, f, this),
  M21_ (x.M21_, f, this),
  M22_ (x.M22_, f, this),
  M23_ (x.M23_, f, this),
  M30_ (x.M30_, f, this),
  M31_ (x.M31_, f, this),
  M32_ (x.M32_, f, this),
  M33_ (x.M33_, f, this)
{
}

ToWorld::
ToWorld (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  X_ (this),
  Y_ (this),
  Z_ (this),
  XR_ (this),
  YR_ (this),
  ZR_ (this),
  M00_ (this),
  M01_ (this),
  M02_ (this),
  M03_ (this),
  M10_ (this),
  M11_ (this),
  M12_ (this),
  M13_ (this),
  M20_ (this),
  M21_ (this),
  M22_ (this),
  M23_ (this),
  M30_ (this),
  M31_ (this),
  M32_ (this),
  M33_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void ToWorld::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "X" && n.namespace_ ().empty ())
    {
      this->X_.set (X_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Y" && n.namespace_ ().empty ())
    {
      this->Y_.set (Y_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Z" && n.namespace_ ().empty ())
    {
      this->Z_.set (Z_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "XR" && n.namespace_ ().empty ())
    {
      this->XR_.set (XR_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "YR" && n.namespace_ ().empty ())
    {
      this->YR_.set (YR_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "ZR" && n.namespace_ ().empty ())
    {
      this->ZR_.set (ZR_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "M00" && n.namespace_ ().empty ())
    {
      this->M00_.set (M00_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "M01" && n.namespace_ ().empty ())
    {
      this->M01_.set (M01_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "M02" && n.namespace_ ().empty ())
    {
      this->M02_.set (M02_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "M03" && n.namespace_ ().empty ())
    {
      this->M03_.set (M03_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "M10" && n.namespace_ ().empty ())
    {
      this->M10_.set (M10_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "M11" && n.namespace_ ().empty ())
    {
      this->M11_.set (M11_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "M12" && n.namespace_ ().empty ())
    {
      this->M12_.set (M12_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "M13" && n.namespace_ ().empty ())
    {
      this->M13_.set (M13_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "M20" && n.namespace_ ().empty ())
    {
      this->M20_.set (M20_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "M21" && n.namespace_ ().empty ())
    {
      this->M21_.set (M21_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "M22" && n.namespace_ ().empty ())
    {
      this->M22_.set (M22_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "M23" && n.namespace_ ().empty ())
    {
      this->M23_.set (M23_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "M30" && n.namespace_ ().empty ())
    {
      this->M30_.set (M30_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "M31" && n.namespace_ ().empty ())
    {
      this->M31_.set (M31_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "M32" && n.namespace_ ().empty ())
    {
      this->M32_.set (M32_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "M33" && n.namespace_ ().empty ())
    {
      this->M33_.set (M33_traits::create (i, f, this));
      continue;
    }
  }

  if (!X_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "X",
      "");
  }

  if (!Y_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "Y",
      "");
  }

  if (!Z_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "Z",
      "");
  }

  if (!XR_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "XR",
      "");
  }

  if (!YR_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "YR",
      "");
  }

  if (!ZR_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "ZR",
      "");
  }
}

ToWorld* ToWorld::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ToWorld (*this, f, c);
}

ToWorld& ToWorld::
operator= (const ToWorld& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->X_ = x.X_;
    this->Y_ = x.Y_;
    this->Z_ = x.Z_;
    this->XR_ = x.XR_;
    this->YR_ = x.YR_;
    this->ZR_ = x.ZR_;
    this->M00_ = x.M00_;
    this->M01_ = x.M01_;
    this->M02_ = x.M02_;
    this->M03_ = x.M03_;
    this->M10_ = x.M10_;
    this->M11_ = x.M11_;
    this->M12_ = x.M12_;
    this->M13_ = x.M13_;
    this->M20_ = x.M20_;
    this->M21_ = x.M21_;
    this->M22_ = x.M22_;
    this->M23_ = x.M23_;
    this->M30_ = x.M30_;
    this->M31_ = x.M31_;
    this->M32_ = x.M32_;
    this->M33_ = x.M33_;
  }

  return *this;
}

ToWorld::
~ToWorld ()
{
}

// Tool
//

Tool::
Tool (const ID_type& ID,
      const Name_type& Name,
      const X_type& X,
      const Y_type& Y,
      const Z_type& Z,
      const XR_type& XR,
      const YR_type& YR,
      const ZR_type& ZR)
: ::xml_schema::type (),
  ID_ (ID, this),
  Name_ (Name, this),
  X_ (X, this),
  Y_ (Y, this),
  Z_ (Z, this),
  XR_ (XR, this),
  YR_ (YR, this),
  ZR_ (ZR, this),
  Mass_ (this),
  MX_ (this),
  MY_ (this),
  MZ_ (this)
{
}

Tool::
Tool (const Tool& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  ID_ (x.ID_, f, this),
  Name_ (x.Name_, f, this),
  X_ (x.X_, f, this),
  Y_ (x.Y_, f, this),
  Z_ (x.Z_, f, this),
  XR_ (x.XR_, f, this),
  YR_ (x.YR_, f, this),
  ZR_ (x.ZR_, f, this),
  Mass_ (x.Mass_, f, this),
  MX_ (x.MX_, f, this),
  MY_ (x.MY_, f, this),
  MZ_ (x.MZ_, f, this)
{
}

Tool::
Tool (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  ID_ (this),
  Name_ (this),
  X_ (this),
  Y_ (this),
  Z_ (this),
  XR_ (this),
  YR_ (this),
  ZR_ (this),
  Mass_ (this),
  MX_ (this),
  MY_ (this),
  MZ_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void Tool::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "ID" && n.namespace_ ().empty ())
    {
      this->ID_.set (ID_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Name" && n.namespace_ ().empty ())
    {
      this->Name_.set (Name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "X" && n.namespace_ ().empty ())
    {
      this->X_.set (X_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Y" && n.namespace_ ().empty ())
    {
      this->Y_.set (Y_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Z" && n.namespace_ ().empty ())
    {
      this->Z_.set (Z_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "XR" && n.namespace_ ().empty ())
    {
      this->XR_.set (XR_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "YR" && n.namespace_ ().empty ())
    {
      this->YR_.set (YR_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "ZR" && n.namespace_ ().empty ())
    {
      this->ZR_.set (ZR_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Mass" && n.namespace_ ().empty ())
    {
      this->Mass_.set (Mass_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "MX" && n.namespace_ ().empty ())
    {
      this->MX_.set (MX_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "MY" && n.namespace_ ().empty ())
    {
      this->MY_.set (MY_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "MZ" && n.namespace_ ().empty ())
    {
      this->MZ_.set (MZ_traits::create (i, f, this));
      continue;
    }
  }

  if (!ID_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "ID",
      "");
  }

  if (!Name_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "Name",
      "");
  }

  if (!X_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "X",
      "");
  }

  if (!Y_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "Y",
      "");
  }

  if (!Z_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "Z",
      "");
  }

  if (!XR_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "XR",
      "");
  }

  if (!YR_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "YR",
      "");
  }

  if (!ZR_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "ZR",
      "");
  }
}

Tool* Tool::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Tool (*this, f, c);
}

Tool& Tool::
operator= (const Tool& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->ID_ = x.ID_;
    this->Name_ = x.Name_;
    this->X_ = x.X_;
    this->Y_ = x.Y_;
    this->Z_ = x.Z_;
    this->XR_ = x.XR_;
    this->YR_ = x.YR_;
    this->ZR_ = x.ZR_;
    this->Mass_ = x.Mass_;
    this->MX_ = x.MX_;
    this->MY_ = x.MY_;
    this->MZ_ = x.MZ_;
  }

  return *this;
}

Tool::
~Tool ()
{
}

// use_simulated_gripper_joint
//

use_simulated_gripper_joint::
use_simulated_gripper_joint ()
: ::xml_schema::type ()
{
}

use_simulated_gripper_joint::
use_simulated_gripper_joint (const use_simulated_gripper_joint& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c)
{
}

use_simulated_gripper_joint::
use_simulated_gripper_joint (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
: ::xml_schema::type (e, f, c)
{
}

use_simulated_gripper_joint::
use_simulated_gripper_joint (const ::xercesc::DOMAttr& a,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
: ::xml_schema::type (a, f, c)
{
}

use_simulated_gripper_joint::
use_simulated_gripper_joint (const ::std::string& s,
                             const ::xercesc::DOMElement* e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
: ::xml_schema::type (s, e, f, c)
{
}

use_simulated_gripper_joint* use_simulated_gripper_joint::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class use_simulated_gripper_joint (*this, f, c);
}

use_simulated_gripper_joint::
~use_simulated_gripper_joint ()
{
}

// robot
//

const robot::version_type robot::version_default_value_ (
  "1.0");

robot::
robot (const TCP_IP_type& TCP_IP,
       const name_type& name)
: ::xml_schema::type (),
  Debug_ (this),
  CrpiType_ (this),
  TCP_IP_ (TCP_IP, this),
  ComType_ (this),
  CRCL_Robot_ (this),
  Mounting_ (this),
  ToWorld_ (this),
  Tool_ (this),
  link_ (this),
  joint_ (this),
  name_ (name, this),
  version_ (version_default_value (), this)
{
}

robot::
robot (::std::auto_ptr< TCP_IP_type > TCP_IP,
       const name_type& name)
: ::xml_schema::type (),
  Debug_ (this),
  CrpiType_ (this),
  TCP_IP_ (TCP_IP, this),
  ComType_ (this),
  CRCL_Robot_ (this),
  Mounting_ (this),
  ToWorld_ (this),
  Tool_ (this),
  link_ (this),
  joint_ (this),
  name_ (name, this),
  version_ (version_default_value (), this)
{
}

robot::
robot (const robot& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Debug_ (x.Debug_, f, this),
  CrpiType_ (x.CrpiType_, f, this),
  TCP_IP_ (x.TCP_IP_, f, this),
  ComType_ (x.ComType_, f, this),
  CRCL_Robot_ (x.CRCL_Robot_, f, this),
  Mounting_ (x.Mounting_, f, this),
  ToWorld_ (x.ToWorld_, f, this),
  Tool_ (x.Tool_, f, this),
  link_ (x.link_, f, this),
  joint_ (x.joint_, f, this),
  name_ (x.name_, f, this),
  version_ (x.version_, f, this)
{
}

robot::
robot (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Debug_ (this),
  CrpiType_ (this),
  TCP_IP_ (this),
  ComType_ (this),
  CRCL_Robot_ (this),
  Mounting_ (this),
  ToWorld_ (this),
  Tool_ (this),
  link_ (this),
  joint_ (this),
  name_ (this),
  version_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void robot::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Debug
    //
    if (n.name () == "Debug" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Debug_type > r (
        Debug_traits::create (i, f, this));

      if (!this->Debug_)
      {
        this->Debug_.set (r);
        continue;
      }
    }

    // CrpiType
    //
    if (n.name () == "CrpiType" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< CrpiType_type > r (
        CrpiType_traits::create (i, f, this));

      if (!this->CrpiType_)
      {
        this->CrpiType_.set (r);
        continue;
      }
    }

    // TCP_IP
    //
    if (n.name () == "TCP_IP" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< TCP_IP_type > r (
        TCP_IP_traits::create (i, f, this));

      if (!TCP_IP_.present ())
      {
        this->TCP_IP_.set (r);
        continue;
      }
    }

    // ComType
    //
    if (n.name () == "ComType" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ComType_type > r (
        ComType_traits::create (i, f, this));

      if (!this->ComType_)
      {
        this->ComType_.set (r);
        continue;
      }
    }

    // CRCL_Robot
    //
    if (n.name () == "CRCL_Robot" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< CRCL_Robot_type > r (
        CRCL_Robot_traits::create (i, f, this));

      if (!this->CRCL_Robot_)
      {
        this->CRCL_Robot_.set (r);
        continue;
      }
    }

    // Mounting
    //
    if (n.name () == "Mounting" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Mounting_type > r (
        Mounting_traits::create (i, f, this));

      if (!this->Mounting_)
      {
        this->Mounting_.set (r);
        continue;
      }
    }

    // ToWorld
    //
    if (n.name () == "ToWorld" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ToWorld_type > r (
        ToWorld_traits::create (i, f, this));

      if (!this->ToWorld_)
      {
        this->ToWorld_.set (r);
        continue;
      }
    }

    // Tool
    //
    if (n.name () == "Tool" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Tool_type > r (
        Tool_traits::create (i, f, this));

      this->Tool_.push_back (r);
      continue;
    }

    // link
    //
    if (n.name () == "link" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< link_type > r (
        link_traits::create (i, f, this));

      this->link_.push_back (r);
      continue;
    }

    // joint
    //
    if (n.name () == "joint" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< joint_type > r (
        joint_traits::create (i, f, this));

      this->joint_.push_back (r);
      continue;
    }

    break;
  }

  if (!TCP_IP_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "TCP_IP",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "version" && n.namespace_ ().empty ())
    {
      this->version_.set (version_traits::create (i, f, this));
      continue;
    }
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "name",
      "");
  }

  if (!version_.present ())
  {
    this->version_.set (version_default_value ());
  }
}

robot* robot::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class robot (*this, f, c);
}

robot& robot::
operator= (const robot& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Debug_ = x.Debug_;
    this->CrpiType_ = x.CrpiType_;
    this->TCP_IP_ = x.TCP_IP_;
    this->ComType_ = x.ComType_;
    this->CRCL_Robot_ = x.CRCL_Robot_;
    this->Mounting_ = x.Mounting_;
    this->ToWorld_ = x.ToWorld_;
    this->Tool_ = x.Tool_;
    this->link_ = x.link_;
    this->joint_ = x.joint_;
    this->name_ = x.name_;
    this->version_ = x.version_;
  }

  return *this;
}

robot::
~robot ()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::auto_ptr< ::robot >
robot_ (const ::std::string& u,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::robot > (
    ::robot_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::robot >
robot_ (const ::std::string& u,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::robot > (
    ::robot_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::robot >
robot_ (const ::std::string& u,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::robot > (
    ::robot_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::robot >
robot_ (::std::istream& is,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::robot_ (isrc, f, p);
}

::std::auto_ptr< ::robot >
robot_ (::std::istream& is,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::robot_ (isrc, h, f, p);
}

::std::auto_ptr< ::robot >
robot_ (::std::istream& is,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::robot_ (isrc, h, f, p);
}

::std::auto_ptr< ::robot >
robot_ (::std::istream& is,
        const ::std::string& sid,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::robot_ (isrc, f, p);
}

::std::auto_ptr< ::robot >
robot_ (::std::istream& is,
        const ::std::string& sid,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::robot_ (isrc, h, f, p);
}

::std::auto_ptr< ::robot >
robot_ (::std::istream& is,
        const ::std::string& sid,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::robot_ (isrc, h, f, p);
}

::std::auto_ptr< ::robot >
robot_ (::xercesc::InputSource& i,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::robot > (
    ::robot_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::robot >
robot_ (::xercesc::InputSource& i,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::robot > (
    ::robot_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::robot >
robot_ (::xercesc::InputSource& i,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::robot > (
    ::robot_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::robot >
robot_ (const ::xercesc::DOMDocument& doc,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::robot > (
      ::robot_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "robot" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::robot > r (
      ::xsd::cxx::tree::traits< ::robot, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "robot",
    "");
}

::std::auto_ptr< ::robot >
robot_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
        ::xml_schema::flags f,
        const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "robot" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::robot > r (
      ::xsd::cxx::tree::traits< ::robot, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "robot",
    "");
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

