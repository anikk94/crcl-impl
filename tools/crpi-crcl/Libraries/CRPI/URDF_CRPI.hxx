// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef CXX______SCHEMAS_URDF_CRPI_HXX
#define CXX______SCHEMAS_URDF_CRPI_HXX

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< char, type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< char, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;
  typedef ::xsd::cxx::tree::token< char, normalized_string > token;
  typedef ::xsd::cxx::tree::name< char, token > name;
  typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< char, name > ncname;
  typedef ::xsd::cxx::tree::language< char, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< char, ncname > id;
  typedef ::xsd::cxx::tree::idref< char, ncname, type > idref;
  typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< char, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< char > buffer;
  typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< char, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< char, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< char, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< char, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< char, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< char, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< char, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< char, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< char, ncname > entity;
  typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;

  typedef ::xsd::cxx::tree::content_order content_order;
  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< char > properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< char > error;
  typedef ::xsd::cxx::tree::diagnostics< char > diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< char > exception;
  typedef ::xsd::cxx::tree::bounds< char > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;
  typedef ::xsd::cxx::tree::parsing< char > parsing;
  typedef ::xsd::cxx::tree::expected_element< char > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< char > expected_text_content;
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::auto_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
class pose;
class color;
class verbose;
class name;
class mass;
class inertia;
class inertial;
class box;
class cylinder;
class sphere;
class mesh;
class geometry;
class texture;
class material;
class material_global;
class visual;
class collision;
class link;
class parent;
class child;
class axis;
class calibration;
class dynamics;
class limit;
class safety_controller;
class mimic;
class actuator_transmission;
class gap_joint_transmission;
class passive_joint_transmission;
class transmission;
class joint;
class Debug;
class CrpiType;
class TCP_IP;
class ComType;
class CRCL_Robot;
class Mounting;
class ToWorld;
class Tool;
class use_simulated_gripper_joint;
class robot;

#include <memory>    // ::std::auto_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

class pose: public ::xml_schema::type
{
  public:
  // xyz
  //
  typedef ::xml_schema::string xyz_type;
  typedef ::xsd::cxx::tree::traits< xyz_type, char > xyz_traits;

  const xyz_type&
  xyz () const;

  xyz_type&
  xyz ();

  void
  xyz (const xyz_type& x);

  void
  xyz (::std::auto_ptr< xyz_type > p);

  static const xyz_type&
  xyz_default_value ();

  // rpy
  //
  typedef ::xml_schema::string rpy_type;
  typedef ::xsd::cxx::tree::traits< rpy_type, char > rpy_traits;

  const rpy_type&
  rpy () const;

  rpy_type&
  rpy ();

  void
  rpy (const rpy_type& x);

  void
  rpy (::std::auto_ptr< rpy_type > p);

  static const rpy_type&
  rpy_default_value ();

  // Constructors.
  //
  pose ();

  pose (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  pose (const pose& x,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  virtual pose*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  pose&
  operator= (const pose& x);

  virtual 
  ~pose ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< xyz_type > xyz_;
  static const xyz_type xyz_default_value_;
  ::xsd::cxx::tree::one< rpy_type > rpy_;
  static const rpy_type rpy_default_value_;
};

class color: public ::xml_schema::type
{
  public:
  // rgba
  //
  typedef ::xml_schema::string rgba_type;
  typedef ::xsd::cxx::tree::traits< rgba_type, char > rgba_traits;

  const rgba_type&
  rgba () const;

  rgba_type&
  rgba ();

  void
  rgba (const rgba_type& x);

  void
  rgba (::std::auto_ptr< rgba_type > p);

  static const rgba_type&
  rgba_default_value ();

  // Constructors.
  //
  color ();

  color (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  color (const color& x,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  virtual color*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  color&
  operator= (const color& x);

  virtual 
  ~color ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< rgba_type > rgba_;
  static const rgba_type rgba_default_value_;
};

class verbose: public ::xml_schema::type
{
  public:
  // value
  //
  typedef ::xml_schema::string value_type;
  typedef ::xsd::cxx::tree::optional< value_type > value_optional;
  typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

  const value_optional&
  value () const;

  value_optional&
  value ();

  void
  value (const value_type& x);

  void
  value (const value_optional& x);

  void
  value (::std::auto_ptr< value_type > p);

  // Constructors.
  //
  verbose ();

  verbose (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  verbose (const verbose& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  virtual verbose*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  verbose&
  operator= (const verbose& x);

  virtual 
  ~verbose ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  value_optional value_;
};

class name: public ::xml_schema::type
{
  public:
  // name
  //
  typedef ::xml_schema::string name1_type;
  typedef ::xsd::cxx::tree::optional< name1_type > name1_optional;
  typedef ::xsd::cxx::tree::traits< name1_type, char > name1_traits;

  const name1_optional&
  name1 () const;

  name1_optional&
  name1 ();

  void
  name1 (const name1_type& x);

  void
  name1 (const name1_optional& x);

  void
  name1 (::std::auto_ptr< name1_type > p);

  // Constructors.
  //
  name ();

  name (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  name (const name& x,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  virtual name*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  name&
  operator= (const name& x);

  virtual 
  ~name ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  name1_optional name1_;
};

class mass: public ::xml_schema::type
{
  public:
  // value
  //
  typedef ::xml_schema::double_ value_type;
  typedef ::xsd::cxx::tree::traits< value_type, char, ::xsd::cxx::tree::schema_type::double_ > value_traits;

  const value_type&
  value () const;

  value_type&
  value ();

  void
  value (const value_type& x);

  static value_type
  value_default_value ();

  // Constructors.
  //
  mass ();

  mass (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  mass (const mass& x,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  virtual mass*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  mass&
  operator= (const mass& x);

  virtual 
  ~mass ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< value_type > value_;
};

class inertia: public ::xml_schema::type
{
  public:
  // ixx
  //
  typedef ::xml_schema::double_ ixx_type;
  typedef ::xsd::cxx::tree::traits< ixx_type, char, ::xsd::cxx::tree::schema_type::double_ > ixx_traits;

  const ixx_type&
  ixx () const;

  ixx_type&
  ixx ();

  void
  ixx (const ixx_type& x);

  static ixx_type
  ixx_default_value ();

  // ixy
  //
  typedef ::xml_schema::double_ ixy_type;
  typedef ::xsd::cxx::tree::traits< ixy_type, char, ::xsd::cxx::tree::schema_type::double_ > ixy_traits;

  const ixy_type&
  ixy () const;

  ixy_type&
  ixy ();

  void
  ixy (const ixy_type& x);

  static ixy_type
  ixy_default_value ();

  // ixz
  //
  typedef ::xml_schema::double_ ixz_type;
  typedef ::xsd::cxx::tree::traits< ixz_type, char, ::xsd::cxx::tree::schema_type::double_ > ixz_traits;

  const ixz_type&
  ixz () const;

  ixz_type&
  ixz ();

  void
  ixz (const ixz_type& x);

  static ixz_type
  ixz_default_value ();

  // iyy
  //
  typedef ::xml_schema::double_ iyy_type;
  typedef ::xsd::cxx::tree::traits< iyy_type, char, ::xsd::cxx::tree::schema_type::double_ > iyy_traits;

  const iyy_type&
  iyy () const;

  iyy_type&
  iyy ();

  void
  iyy (const iyy_type& x);

  static iyy_type
  iyy_default_value ();

  // iyz
  //
  typedef ::xml_schema::double_ iyz_type;
  typedef ::xsd::cxx::tree::traits< iyz_type, char, ::xsd::cxx::tree::schema_type::double_ > iyz_traits;

  const iyz_type&
  iyz () const;

  iyz_type&
  iyz ();

  void
  iyz (const iyz_type& x);

  static iyz_type
  iyz_default_value ();

  // izz
  //
  typedef ::xml_schema::double_ izz_type;
  typedef ::xsd::cxx::tree::traits< izz_type, char, ::xsd::cxx::tree::schema_type::double_ > izz_traits;

  const izz_type&
  izz () const;

  izz_type&
  izz ();

  void
  izz (const izz_type& x);

  static izz_type
  izz_default_value ();

  // Constructors.
  //
  inertia ();

  inertia (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  inertia (const inertia& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  virtual inertia*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  inertia&
  operator= (const inertia& x);

  virtual 
  ~inertia ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< ixx_type > ixx_;
  ::xsd::cxx::tree::one< ixy_type > ixy_;
  ::xsd::cxx::tree::one< ixz_type > ixz_;
  ::xsd::cxx::tree::one< iyy_type > iyy_;
  ::xsd::cxx::tree::one< iyz_type > iyz_;
  ::xsd::cxx::tree::one< izz_type > izz_;
};

class inertial: public ::xml_schema::type
{
  public:
  // origin
  //
  typedef ::pose origin_type;
  typedef ::xsd::cxx::tree::optional< origin_type > origin_optional;
  typedef ::xsd::cxx::tree::traits< origin_type, char > origin_traits;

  const origin_optional&
  origin () const;

  origin_optional&
  origin ();

  void
  origin (const origin_type& x);

  void
  origin (const origin_optional& x);

  void
  origin (::std::auto_ptr< origin_type > p);

  // mass
  //
  typedef ::mass mass_type;
  typedef ::xsd::cxx::tree::optional< mass_type > mass_optional;
  typedef ::xsd::cxx::tree::traits< mass_type, char > mass_traits;

  const mass_optional&
  mass () const;

  mass_optional&
  mass ();

  void
  mass (const mass_type& x);

  void
  mass (const mass_optional& x);

  void
  mass (::std::auto_ptr< mass_type > p);

  // inertia
  //
  typedef ::inertia inertia_type;
  typedef ::xsd::cxx::tree::optional< inertia_type > inertia_optional;
  typedef ::xsd::cxx::tree::traits< inertia_type, char > inertia_traits;

  const inertia_optional&
  inertia () const;

  inertia_optional&
  inertia ();

  void
  inertia (const inertia_type& x);

  void
  inertia (const inertia_optional& x);

  void
  inertia (::std::auto_ptr< inertia_type > p);

  // Constructors.
  //
  inertial ();

  inertial (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  inertial (const inertial& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual inertial*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  inertial&
  operator= (const inertial& x);

  virtual 
  ~inertial ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  origin_optional origin_;
  mass_optional mass_;
  inertia_optional inertia_;
};

class box: public ::xml_schema::type
{
  public:
  // size
  //
  typedef ::xml_schema::string size_type;
  typedef ::xsd::cxx::tree::traits< size_type, char > size_traits;

  const size_type&
  size () const;

  size_type&
  size ();

  void
  size (const size_type& x);

  void
  size (::std::auto_ptr< size_type > p);

  static const size_type&
  size_default_value ();

  // Constructors.
  //
  box ();

  box (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f = 0,
       ::xml_schema::container* c = 0);

  box (const box& x,
       ::xml_schema::flags f = 0,
       ::xml_schema::container* c = 0);

  virtual box*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  box&
  operator= (const box& x);

  virtual 
  ~box ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< size_type > size_;
  static const size_type size_default_value_;
};

class cylinder: public ::xml_schema::type
{
  public:
  // radius
  //
  typedef ::xml_schema::double_ radius_type;
  typedef ::xsd::cxx::tree::traits< radius_type, char, ::xsd::cxx::tree::schema_type::double_ > radius_traits;

  const radius_type&
  radius () const;

  radius_type&
  radius ();

  void
  radius (const radius_type& x);

  // length
  //
  typedef ::xml_schema::double_ length_type;
  typedef ::xsd::cxx::tree::traits< length_type, char, ::xsd::cxx::tree::schema_type::double_ > length_traits;

  const length_type&
  length () const;

  length_type&
  length ();

  void
  length (const length_type& x);

  // Constructors.
  //
  cylinder (const radius_type&,
            const length_type&);

  cylinder (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  cylinder (const cylinder& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual cylinder*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  cylinder&
  operator= (const cylinder& x);

  virtual 
  ~cylinder ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< radius_type > radius_;
  ::xsd::cxx::tree::one< length_type > length_;
};

class sphere: public ::xml_schema::type
{
  public:
  // radius
  //
  typedef ::xml_schema::double_ radius_type;
  typedef ::xsd::cxx::tree::traits< radius_type, char, ::xsd::cxx::tree::schema_type::double_ > radius_traits;

  const radius_type&
  radius () const;

  radius_type&
  radius ();

  void
  radius (const radius_type& x);

  // Constructors.
  //
  sphere (const radius_type&);

  sphere (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  sphere (const sphere& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  virtual sphere*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  sphere&
  operator= (const sphere& x);

  virtual 
  ~sphere ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< radius_type > radius_;
};

class mesh: public ::xml_schema::type
{
  public:
  // filename
  //
  typedef ::xml_schema::uri filename_type;
  typedef ::xsd::cxx::tree::traits< filename_type, char > filename_traits;

  const filename_type&
  filename () const;

  filename_type&
  filename ();

  void
  filename (const filename_type& x);

  void
  filename (::std::auto_ptr< filename_type > p);

  // scale
  //
  typedef ::xml_schema::string scale_type;
  typedef ::xsd::cxx::tree::traits< scale_type, char > scale_traits;

  const scale_type&
  scale () const;

  scale_type&
  scale ();

  void
  scale (const scale_type& x);

  void
  scale (::std::auto_ptr< scale_type > p);

  static const scale_type&
  scale_default_value ();

  // Constructors.
  //
  mesh (const filename_type&);

  mesh (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  mesh (const mesh& x,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  virtual mesh*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  mesh&
  operator= (const mesh& x);

  virtual 
  ~mesh ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< filename_type > filename_;
  ::xsd::cxx::tree::one< scale_type > scale_;
  static const scale_type scale_default_value_;
};

class geometry: public ::xml_schema::type
{
  public:
  // box
  //
  typedef ::box box_type;
  typedef ::xsd::cxx::tree::optional< box_type > box_optional;
  typedef ::xsd::cxx::tree::traits< box_type, char > box_traits;

  const box_optional&
  box () const;

  box_optional&
  box ();

  void
  box (const box_type& x);

  void
  box (const box_optional& x);

  void
  box (::std::auto_ptr< box_type > p);

  // cylinder
  //
  typedef ::cylinder cylinder_type;
  typedef ::xsd::cxx::tree::optional< cylinder_type > cylinder_optional;
  typedef ::xsd::cxx::tree::traits< cylinder_type, char > cylinder_traits;

  const cylinder_optional&
  cylinder () const;

  cylinder_optional&
  cylinder ();

  void
  cylinder (const cylinder_type& x);

  void
  cylinder (const cylinder_optional& x);

  void
  cylinder (::std::auto_ptr< cylinder_type > p);

  // sphere
  //
  typedef ::sphere sphere_type;
  typedef ::xsd::cxx::tree::optional< sphere_type > sphere_optional;
  typedef ::xsd::cxx::tree::traits< sphere_type, char > sphere_traits;

  const sphere_optional&
  sphere () const;

  sphere_optional&
  sphere ();

  void
  sphere (const sphere_type& x);

  void
  sphere (const sphere_optional& x);

  void
  sphere (::std::auto_ptr< sphere_type > p);

  // mesh
  //
  typedef ::mesh mesh_type;
  typedef ::xsd::cxx::tree::optional< mesh_type > mesh_optional;
  typedef ::xsd::cxx::tree::traits< mesh_type, char > mesh_traits;

  const mesh_optional&
  mesh () const;

  mesh_optional&
  mesh ();

  void
  mesh (const mesh_type& x);

  void
  mesh (const mesh_optional& x);

  void
  mesh (::std::auto_ptr< mesh_type > p);

  // Constructors.
  //
  geometry ();

  geometry (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  geometry (const geometry& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual geometry*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  geometry&
  operator= (const geometry& x);

  virtual 
  ~geometry ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  box_optional box_;
  cylinder_optional cylinder_;
  sphere_optional sphere_;
  mesh_optional mesh_;
};

class texture: public ::xml_schema::type
{
  public:
  // filename
  //
  typedef ::xml_schema::uri filename_type;
  typedef ::xsd::cxx::tree::optional< filename_type > filename_optional;
  typedef ::xsd::cxx::tree::traits< filename_type, char > filename_traits;

  const filename_optional&
  filename () const;

  filename_optional&
  filename ();

  void
  filename (const filename_type& x);

  void
  filename (const filename_optional& x);

  void
  filename (::std::auto_ptr< filename_type > p);

  // Constructors.
  //
  texture ();

  texture (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  texture (const texture& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  virtual texture*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  texture&
  operator= (const texture& x);

  virtual 
  ~texture ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  filename_optional filename_;
};

class material: public ::xml_schema::type
{
  public:
  // color
  //
  typedef ::color color_type;
  typedef ::xsd::cxx::tree::optional< color_type > color_optional;
  typedef ::xsd::cxx::tree::traits< color_type, char > color_traits;

  const color_optional&
  color () const;

  color_optional&
  color ();

  void
  color (const color_type& x);

  void
  color (const color_optional& x);

  void
  color (::std::auto_ptr< color_type > p);

  // texture
  //
  typedef ::texture texture_type;
  typedef ::xsd::cxx::tree::optional< texture_type > texture_optional;
  typedef ::xsd::cxx::tree::traits< texture_type, char > texture_traits;

  const texture_optional&
  texture () const;

  texture_optional&
  texture ();

  void
  texture (const texture_type& x);

  void
  texture (const texture_optional& x);

  void
  texture (::std::auto_ptr< texture_type > p);

  // name
  //
  typedef ::xml_schema::string name_type;
  typedef ::xsd::cxx::tree::optional< name_type > name_optional;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_optional&
  name () const;

  name_optional&
  name ();

  void
  name (const name_type& x);

  void
  name (const name_optional& x);

  void
  name (::std::auto_ptr< name_type > p);

  // Constructors.
  //
  material ();

  material (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  material (const material& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual material*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  material&
  operator= (const material& x);

  virtual 
  ~material ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  color_optional color_;
  texture_optional texture_;
  name_optional name_;
};

class material_global: public ::xml_schema::type
{
  public:
  // color
  //
  typedef ::color color_type;
  typedef ::xsd::cxx::tree::optional< color_type > color_optional;
  typedef ::xsd::cxx::tree::traits< color_type, char > color_traits;

  const color_optional&
  color () const;

  color_optional&
  color ();

  void
  color (const color_type& x);

  void
  color (const color_optional& x);

  void
  color (::std::auto_ptr< color_type > p);

  // texture
  //
  typedef ::texture texture_type;
  typedef ::xsd::cxx::tree::optional< texture_type > texture_optional;
  typedef ::xsd::cxx::tree::traits< texture_type, char > texture_traits;

  const texture_optional&
  texture () const;

  texture_optional&
  texture ();

  void
  texture (const texture_type& x);

  void
  texture (const texture_optional& x);

  void
  texture (::std::auto_ptr< texture_type > p);

  // name
  //
  typedef ::xml_schema::string name_type;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_type&
  name () const;

  name_type&
  name ();

  void
  name (const name_type& x);

  void
  name (::std::auto_ptr< name_type > p);

  // Constructors.
  //
  material_global (const name_type&);

  material_global (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  material_global (const material_global& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  virtual material_global*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  material_global&
  operator= (const material_global& x);

  virtual 
  ~material_global ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  color_optional color_;
  texture_optional texture_;
  ::xsd::cxx::tree::one< name_type > name_;
};

class visual: public ::xml_schema::type
{
  public:
  // origin
  //
  typedef ::pose origin_type;
  typedef ::xsd::cxx::tree::optional< origin_type > origin_optional;
  typedef ::xsd::cxx::tree::traits< origin_type, char > origin_traits;

  const origin_optional&
  origin () const;

  origin_optional&
  origin ();

  void
  origin (const origin_type& x);

  void
  origin (const origin_optional& x);

  void
  origin (::std::auto_ptr< origin_type > p);

  // geometry
  //
  typedef ::geometry geometry_type;
  typedef ::xsd::cxx::tree::traits< geometry_type, char > geometry_traits;

  const geometry_type&
  geometry () const;

  geometry_type&
  geometry ();

  void
  geometry (const geometry_type& x);

  void
  geometry (::std::auto_ptr< geometry_type > p);

  // material
  //
  typedef ::material material_type;
  typedef ::xsd::cxx::tree::optional< material_type > material_optional;
  typedef ::xsd::cxx::tree::traits< material_type, char > material_traits;

  const material_optional&
  material () const;

  material_optional&
  material ();

  void
  material (const material_type& x);

  void
  material (const material_optional& x);

  void
  material (::std::auto_ptr< material_type > p);

  // Constructors.
  //
  visual (const geometry_type&);

  visual (::std::auto_ptr< geometry_type >);

  visual (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  visual (const visual& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  virtual visual*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  visual&
  operator= (const visual& x);

  virtual 
  ~visual ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  origin_optional origin_;
  ::xsd::cxx::tree::one< geometry_type > geometry_;
  material_optional material_;
};

class collision: public ::xml_schema::type
{
  public:
  // origin
  //
  typedef ::pose origin_type;
  typedef ::xsd::cxx::tree::optional< origin_type > origin_optional;
  typedef ::xsd::cxx::tree::traits< origin_type, char > origin_traits;

  const origin_optional&
  origin () const;

  origin_optional&
  origin ();

  void
  origin (const origin_type& x);

  void
  origin (const origin_optional& x);

  void
  origin (::std::auto_ptr< origin_type > p);

  // geometry
  //
  typedef ::geometry geometry_type;
  typedef ::xsd::cxx::tree::traits< geometry_type, char > geometry_traits;

  const geometry_type&
  geometry () const;

  geometry_type&
  geometry ();

  void
  geometry (const geometry_type& x);

  void
  geometry (::std::auto_ptr< geometry_type > p);

  // verbose
  //
  typedef ::verbose verbose_type;
  typedef ::xsd::cxx::tree::optional< verbose_type > verbose_optional;
  typedef ::xsd::cxx::tree::traits< verbose_type, char > verbose_traits;

  const verbose_optional&
  verbose () const;

  verbose_optional&
  verbose ();

  void
  verbose (const verbose_type& x);

  void
  verbose (const verbose_optional& x);

  void
  verbose (::std::auto_ptr< verbose_type > p);

  // name
  //
  typedef ::xml_schema::string name_type;
  typedef ::xsd::cxx::tree::optional< name_type > name_optional;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_optional&
  name () const;

  name_optional&
  name ();

  void
  name (const name_type& x);

  void
  name (const name_optional& x);

  void
  name (::std::auto_ptr< name_type > p);

  // Constructors.
  //
  collision (const geometry_type&);

  collision (::std::auto_ptr< geometry_type >);

  collision (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  collision (const collision& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  virtual collision*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  collision&
  operator= (const collision& x);

  virtual 
  ~collision ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  origin_optional origin_;
  ::xsd::cxx::tree::one< geometry_type > geometry_;
  verbose_optional verbose_;
  name_optional name_;
};

class link: public ::xml_schema::type
{
  public:
  // inertial
  //
  typedef ::inertial inertial_type;
  typedef ::xsd::cxx::tree::optional< inertial_type > inertial_optional;
  typedef ::xsd::cxx::tree::traits< inertial_type, char > inertial_traits;

  const inertial_optional&
  inertial () const;

  inertial_optional&
  inertial ();

  void
  inertial (const inertial_type& x);

  void
  inertial (const inertial_optional& x);

  void
  inertial (::std::auto_ptr< inertial_type > p);

  // visual
  //
  typedef ::visual visual_type;
  typedef ::xsd::cxx::tree::optional< visual_type > visual_optional;
  typedef ::xsd::cxx::tree::traits< visual_type, char > visual_traits;

  const visual_optional&
  visual () const;

  visual_optional&
  visual ();

  void
  visual (const visual_type& x);

  void
  visual (const visual_optional& x);

  void
  visual (::std::auto_ptr< visual_type > p);

  // collision
  //
  typedef ::collision collision_type;
  typedef ::xsd::cxx::tree::optional< collision_type > collision_optional;
  typedef ::xsd::cxx::tree::traits< collision_type, char > collision_traits;

  const collision_optional&
  collision () const;

  collision_optional&
  collision ();

  void
  collision (const collision_type& x);

  void
  collision (const collision_optional& x);

  void
  collision (::std::auto_ptr< collision_type > p);

  // name
  //
  typedef ::xml_schema::string name_type;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_type&
  name () const;

  name_type&
  name ();

  void
  name (const name_type& x);

  void
  name (::std::auto_ptr< name_type > p);

  // type
  //
  typedef ::xml_schema::string type_type;
  typedef ::xsd::cxx::tree::optional< type_type > type_optional;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_optional&
  type () const;

  type_optional&
  type ();

  void
  type (const type_type& x);

  void
  type (const type_optional& x);

  void
  type (::std::auto_ptr< type_type > p);

  // Constructors.
  //
  link (const name_type&);

  link (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  link (const link& x,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  virtual link*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  link&
  operator= (const link& x);

  virtual 
  ~link ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  inertial_optional inertial_;
  visual_optional visual_;
  collision_optional collision_;
  ::xsd::cxx::tree::one< name_type > name_;
  type_optional type_;
};

class parent: public ::xml_schema::type
{
  public:
  // link
  //
  typedef ::xml_schema::string link_type;
  typedef ::xsd::cxx::tree::traits< link_type, char > link_traits;

  const link_type&
  link () const;

  link_type&
  link ();

  void
  link (const link_type& x);

  void
  link (::std::auto_ptr< link_type > p);

  // Constructors.
  //
  parent (const link_type&);

  parent (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  parent (const parent& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  virtual parent*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  parent&
  operator= (const parent& x);

  virtual 
  ~parent ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< link_type > link_;
};

class child: public ::xml_schema::type
{
  public:
  // link
  //
  typedef ::xml_schema::string link_type;
  typedef ::xsd::cxx::tree::traits< link_type, char > link_traits;

  const link_type&
  link () const;

  link_type&
  link ();

  void
  link (const link_type& x);

  void
  link (::std::auto_ptr< link_type > p);

  // Constructors.
  //
  child (const link_type&);

  child (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  child (const child& x,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  virtual child*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  child&
  operator= (const child& x);

  virtual 
  ~child ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< link_type > link_;
};

class axis: public ::xml_schema::type
{
  public:
  // xyz
  //
  typedef ::xml_schema::string xyz_type;
  typedef ::xsd::cxx::tree::traits< xyz_type, char > xyz_traits;

  const xyz_type&
  xyz () const;

  xyz_type&
  xyz ();

  void
  xyz (const xyz_type& x);

  void
  xyz (::std::auto_ptr< xyz_type > p);

  static const xyz_type&
  xyz_default_value ();

  // Constructors.
  //
  axis ();

  axis (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  axis (const axis& x,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  virtual axis*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  axis&
  operator= (const axis& x);

  virtual 
  ~axis ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< xyz_type > xyz_;
  static const xyz_type xyz_default_value_;
};

class calibration: public ::xml_schema::type
{
  public:
  // reference_position
  //
  typedef ::xml_schema::double_ reference_position_type;
  typedef ::xsd::cxx::tree::optional< reference_position_type > reference_position_optional;
  typedef ::xsd::cxx::tree::traits< reference_position_type, char, ::xsd::cxx::tree::schema_type::double_ > reference_position_traits;

  const reference_position_optional&
  reference_position () const;

  reference_position_optional&
  reference_position ();

  void
  reference_position (const reference_position_type& x);

  void
  reference_position (const reference_position_optional& x);

  // rising
  //
  typedef ::xml_schema::double_ rising_type;
  typedef ::xsd::cxx::tree::optional< rising_type > rising_optional;
  typedef ::xsd::cxx::tree::traits< rising_type, char, ::xsd::cxx::tree::schema_type::double_ > rising_traits;

  const rising_optional&
  rising () const;

  rising_optional&
  rising ();

  void
  rising (const rising_type& x);

  void
  rising (const rising_optional& x);

  // falling
  //
  typedef ::xml_schema::double_ falling_type;
  typedef ::xsd::cxx::tree::optional< falling_type > falling_optional;
  typedef ::xsd::cxx::tree::traits< falling_type, char, ::xsd::cxx::tree::schema_type::double_ > falling_traits;

  const falling_optional&
  falling () const;

  falling_optional&
  falling ();

  void
  falling (const falling_type& x);

  void
  falling (const falling_optional& x);

  // Constructors.
  //
  calibration ();

  calibration (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  calibration (const calibration& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  virtual calibration*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  calibration&
  operator= (const calibration& x);

  virtual 
  ~calibration ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  reference_position_optional reference_position_;
  rising_optional rising_;
  falling_optional falling_;
};

class dynamics: public ::xml_schema::type
{
  public:
  // damping
  //
  typedef ::xml_schema::double_ damping_type;
  typedef ::xsd::cxx::tree::traits< damping_type, char, ::xsd::cxx::tree::schema_type::double_ > damping_traits;

  const damping_type&
  damping () const;

  damping_type&
  damping ();

  void
  damping (const damping_type& x);

  static damping_type
  damping_default_value ();

  // friction
  //
  typedef ::xml_schema::double_ friction_type;
  typedef ::xsd::cxx::tree::traits< friction_type, char, ::xsd::cxx::tree::schema_type::double_ > friction_traits;

  const friction_type&
  friction () const;

  friction_type&
  friction ();

  void
  friction (const friction_type& x);

  static friction_type
  friction_default_value ();

  // Constructors.
  //
  dynamics ();

  dynamics (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  dynamics (const dynamics& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual dynamics*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  dynamics&
  operator= (const dynamics& x);

  virtual 
  ~dynamics ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< damping_type > damping_;
  ::xsd::cxx::tree::one< friction_type > friction_;
};

class limit: public ::xml_schema::type
{
  public:
  // lower
  //
  typedef ::xml_schema::double_ lower_type;
  typedef ::xsd::cxx::tree::traits< lower_type, char, ::xsd::cxx::tree::schema_type::double_ > lower_traits;

  const lower_type&
  lower () const;

  lower_type&
  lower ();

  void
  lower (const lower_type& x);

  static lower_type
  lower_default_value ();

  // upper
  //
  typedef ::xml_schema::double_ upper_type;
  typedef ::xsd::cxx::tree::traits< upper_type, char, ::xsd::cxx::tree::schema_type::double_ > upper_traits;

  const upper_type&
  upper () const;

  upper_type&
  upper ();

  void
  upper (const upper_type& x);

  static upper_type
  upper_default_value ();

  // effort
  //
  typedef ::xml_schema::double_ effort_type;
  typedef ::xsd::cxx::tree::traits< effort_type, char, ::xsd::cxx::tree::schema_type::double_ > effort_traits;

  const effort_type&
  effort () const;

  effort_type&
  effort ();

  void
  effort (const effort_type& x);

  static effort_type
  effort_default_value ();

  // velocity
  //
  typedef ::xml_schema::double_ velocity_type;
  typedef ::xsd::cxx::tree::traits< velocity_type, char, ::xsd::cxx::tree::schema_type::double_ > velocity_traits;

  const velocity_type&
  velocity () const;

  velocity_type&
  velocity ();

  void
  velocity (const velocity_type& x);

  static velocity_type
  velocity_default_value ();

  // Constructors.
  //
  limit ();

  limit (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  limit (const limit& x,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  virtual limit*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  limit&
  operator= (const limit& x);

  virtual 
  ~limit ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< lower_type > lower_;
  ::xsd::cxx::tree::one< upper_type > upper_;
  ::xsd::cxx::tree::one< effort_type > effort_;
  ::xsd::cxx::tree::one< velocity_type > velocity_;
};

class safety_controller: public ::xml_schema::type
{
  public:
  // soft_lower_limit
  //
  typedef ::xml_schema::double_ soft_lower_limit_type;
  typedef ::xsd::cxx::tree::traits< soft_lower_limit_type, char, ::xsd::cxx::tree::schema_type::double_ > soft_lower_limit_traits;

  const soft_lower_limit_type&
  soft_lower_limit () const;

  soft_lower_limit_type&
  soft_lower_limit ();

  void
  soft_lower_limit (const soft_lower_limit_type& x);

  static soft_lower_limit_type
  soft_lower_limit_default_value ();

  // soft_upper_limit
  //
  typedef ::xml_schema::double_ soft_upper_limit_type;
  typedef ::xsd::cxx::tree::traits< soft_upper_limit_type, char, ::xsd::cxx::tree::schema_type::double_ > soft_upper_limit_traits;

  const soft_upper_limit_type&
  soft_upper_limit () const;

  soft_upper_limit_type&
  soft_upper_limit ();

  void
  soft_upper_limit (const soft_upper_limit_type& x);

  static soft_upper_limit_type
  soft_upper_limit_default_value ();

  // k_position
  //
  typedef ::xml_schema::double_ k_position_type;
  typedef ::xsd::cxx::tree::traits< k_position_type, char, ::xsd::cxx::tree::schema_type::double_ > k_position_traits;

  const k_position_type&
  k_position () const;

  k_position_type&
  k_position ();

  void
  k_position (const k_position_type& x);

  static k_position_type
  k_position_default_value ();

  // k_velocity
  //
  typedef ::xml_schema::double_ k_velocity_type;
  typedef ::xsd::cxx::tree::traits< k_velocity_type, char, ::xsd::cxx::tree::schema_type::double_ > k_velocity_traits;

  const k_velocity_type&
  k_velocity () const;

  k_velocity_type&
  k_velocity ();

  void
  k_velocity (const k_velocity_type& x);

  // Constructors.
  //
  safety_controller (const k_velocity_type&);

  safety_controller (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  safety_controller (const safety_controller& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  virtual safety_controller*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  safety_controller&
  operator= (const safety_controller& x);

  virtual 
  ~safety_controller ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< soft_lower_limit_type > soft_lower_limit_;
  ::xsd::cxx::tree::one< soft_upper_limit_type > soft_upper_limit_;
  ::xsd::cxx::tree::one< k_position_type > k_position_;
  ::xsd::cxx::tree::one< k_velocity_type > k_velocity_;
};

class mimic: public ::xml_schema::type
{
  public:
  // joint
  //
  typedef ::xml_schema::string joint_type;
  typedef ::xsd::cxx::tree::traits< joint_type, char > joint_traits;

  const joint_type&
  joint () const;

  joint_type&
  joint ();

  void
  joint (const joint_type& x);

  void
  joint (::std::auto_ptr< joint_type > p);

  // multiplier
  //
  typedef ::xml_schema::double_ multiplier_type;
  typedef ::xsd::cxx::tree::traits< multiplier_type, char, ::xsd::cxx::tree::schema_type::double_ > multiplier_traits;

  const multiplier_type&
  multiplier () const;

  multiplier_type&
  multiplier ();

  void
  multiplier (const multiplier_type& x);

  static multiplier_type
  multiplier_default_value ();

  // offset
  //
  typedef ::xml_schema::double_ offset_type;
  typedef ::xsd::cxx::tree::traits< offset_type, char, ::xsd::cxx::tree::schema_type::double_ > offset_traits;

  const offset_type&
  offset () const;

  offset_type&
  offset ();

  void
  offset (const offset_type& x);

  static offset_type
  offset_default_value ();

  // Constructors.
  //
  mimic (const joint_type&);

  mimic (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  mimic (const mimic& x,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  virtual mimic*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  mimic&
  operator= (const mimic& x);

  virtual 
  ~mimic ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< joint_type > joint_;
  ::xsd::cxx::tree::one< multiplier_type > multiplier_;
  ::xsd::cxx::tree::one< offset_type > offset_;
};

class actuator_transmission: public ::xml_schema::type
{
  public:
  // mechanicalReduction
  //
  typedef ::xml_schema::double_ mechanicalReduction_type;
  typedef ::xsd::cxx::tree::traits< mechanicalReduction_type, char, ::xsd::cxx::tree::schema_type::double_ > mechanicalReduction_traits;

  const mechanicalReduction_type&
  mechanicalReduction () const;

  mechanicalReduction_type&
  mechanicalReduction ();

  void
  mechanicalReduction (const mechanicalReduction_type& x);

  // name
  //
  typedef ::xml_schema::string name_type;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_type&
  name () const;

  name_type&
  name ();

  void
  name (const name_type& x);

  void
  name (::std::auto_ptr< name_type > p);

  // Constructors.
  //
  actuator_transmission (const mechanicalReduction_type&,
                         const name_type&);

  actuator_transmission (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  actuator_transmission (const actuator_transmission& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  virtual actuator_transmission*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  actuator_transmission&
  operator= (const actuator_transmission& x);

  virtual 
  ~actuator_transmission ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< mechanicalReduction_type > mechanicalReduction_;
  ::xsd::cxx::tree::one< name_type > name_;
};

class gap_joint_transmission: public ::xml_schema::type
{
  public:
  // L0
  //
  typedef ::xml_schema::double_ L0_type;
  typedef ::xsd::cxx::tree::traits< L0_type, char, ::xsd::cxx::tree::schema_type::double_ > L0_traits;

  const L0_type&
  L0 () const;

  L0_type&
  L0 ();

  void
  L0 (const L0_type& x);

  // a
  //
  typedef ::xml_schema::double_ a_type;
  typedef ::xsd::cxx::tree::traits< a_type, char, ::xsd::cxx::tree::schema_type::double_ > a_traits;

  const a_type&
  a () const;

  a_type&
  a ();

  void
  a (const a_type& x);

  // b
  //
  typedef ::xml_schema::double_ b_type;
  typedef ::xsd::cxx::tree::traits< b_type, char, ::xsd::cxx::tree::schema_type::double_ > b_traits;

  const b_type&
  b () const;

  b_type&
  b ();

  void
  b (const b_type& x);

  // gear_ratio
  //
  typedef ::xml_schema::double_ gear_ratio_type;
  typedef ::xsd::cxx::tree::traits< gear_ratio_type, char, ::xsd::cxx::tree::schema_type::double_ > gear_ratio_traits;

  const gear_ratio_type&
  gear_ratio () const;

  gear_ratio_type&
  gear_ratio ();

  void
  gear_ratio (const gear_ratio_type& x);

  // h
  //
  typedef ::xml_schema::double_ h_type;
  typedef ::xsd::cxx::tree::traits< h_type, char, ::xsd::cxx::tree::schema_type::double_ > h_traits;

  const h_type&
  h () const;

  h_type&
  h ();

  void
  h (const h_type& x);

  // mechanical_reduction
  //
  typedef ::xml_schema::double_ mechanical_reduction_type;
  typedef ::xsd::cxx::tree::traits< mechanical_reduction_type, char, ::xsd::cxx::tree::schema_type::double_ > mechanical_reduction_traits;

  const mechanical_reduction_type&
  mechanical_reduction () const;

  mechanical_reduction_type&
  mechanical_reduction ();

  void
  mechanical_reduction (const mechanical_reduction_type& x);

  // name
  //
  typedef ::xml_schema::string name_type;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_type&
  name () const;

  name_type&
  name ();

  void
  name (const name_type& x);

  void
  name (::std::auto_ptr< name_type > p);

  // phi0
  //
  typedef ::xml_schema::double_ phi0_type;
  typedef ::xsd::cxx::tree::traits< phi0_type, char, ::xsd::cxx::tree::schema_type::double_ > phi0_traits;

  const phi0_type&
  phi0 () const;

  phi0_type&
  phi0 ();

  void
  phi0 (const phi0_type& x);

  // r
  //
  typedef ::xml_schema::double_ r_type;
  typedef ::xsd::cxx::tree::traits< r_type, char, ::xsd::cxx::tree::schema_type::double_ > r_traits;

  const r_type&
  r () const;

  r_type&
  r ();

  void
  r (const r_type& x);

  // screw_reduction
  //
  typedef ::xml_schema::double_ screw_reduction_type;
  typedef ::xsd::cxx::tree::traits< screw_reduction_type, char, ::xsd::cxx::tree::schema_type::double_ > screw_reduction_traits;

  const screw_reduction_type&
  screw_reduction () const;

  screw_reduction_type&
  screw_reduction ();

  void
  screw_reduction (const screw_reduction_type& x);

  // t0
  //
  typedef ::xml_schema::double_ t0_type;
  typedef ::xsd::cxx::tree::traits< t0_type, char, ::xsd::cxx::tree::schema_type::double_ > t0_traits;

  const t0_type&
  t0 () const;

  t0_type&
  t0 ();

  void
  t0 (const t0_type& x);

  // theta0
  //
  typedef ::xml_schema::double_ theta0_type;
  typedef ::xsd::cxx::tree::traits< theta0_type, char, ::xsd::cxx::tree::schema_type::double_ > theta0_traits;

  const theta0_type&
  theta0 () const;

  theta0_type&
  theta0 ();

  void
  theta0 (const theta0_type& x);

  // Constructors.
  //
  gap_joint_transmission (const L0_type&,
                          const a_type&,
                          const b_type&,
                          const gear_ratio_type&,
                          const h_type&,
                          const mechanical_reduction_type&,
                          const name_type&,
                          const phi0_type&,
                          const r_type&,
                          const screw_reduction_type&,
                          const t0_type&,
                          const theta0_type&);

  gap_joint_transmission (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

  gap_joint_transmission (const gap_joint_transmission& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

  virtual gap_joint_transmission*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  gap_joint_transmission&
  operator= (const gap_joint_transmission& x);

  virtual 
  ~gap_joint_transmission ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< L0_type > L0_;
  ::xsd::cxx::tree::one< a_type > a_;
  ::xsd::cxx::tree::one< b_type > b_;
  ::xsd::cxx::tree::one< gear_ratio_type > gear_ratio_;
  ::xsd::cxx::tree::one< h_type > h_;
  ::xsd::cxx::tree::one< mechanical_reduction_type > mechanical_reduction_;
  ::xsd::cxx::tree::one< name_type > name_;
  ::xsd::cxx::tree::one< phi0_type > phi0_;
  ::xsd::cxx::tree::one< r_type > r_;
  ::xsd::cxx::tree::one< screw_reduction_type > screw_reduction_;
  ::xsd::cxx::tree::one< t0_type > t0_;
  ::xsd::cxx::tree::one< theta0_type > theta0_;
};

class passive_joint_transmission: public ::xml_schema::type
{
  public:
  // name
  //
  typedef ::xml_schema::string name_type;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_type&
  name () const;

  name_type&
  name ();

  void
  name (const name_type& x);

  void
  name (::std::auto_ptr< name_type > p);

  // Constructors.
  //
  passive_joint_transmission (const name_type&);

  passive_joint_transmission (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

  passive_joint_transmission (const passive_joint_transmission& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

  virtual passive_joint_transmission*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  passive_joint_transmission&
  operator= (const passive_joint_transmission& x);

  virtual 
  ~passive_joint_transmission ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< name_type > name_;
};

class transmission: public ::xml_schema::type
{
  public:
  // leftActuator
  //
  typedef ::actuator_transmission leftActuator_type;
  typedef ::xsd::cxx::tree::sequence< leftActuator_type > leftActuator_sequence;
  typedef leftActuator_sequence::iterator leftActuator_iterator;
  typedef leftActuator_sequence::const_iterator leftActuator_const_iterator;
  typedef ::xsd::cxx::tree::traits< leftActuator_type, char > leftActuator_traits;

  const leftActuator_sequence&
  leftActuator () const;

  leftActuator_sequence&
  leftActuator ();

  void
  leftActuator (const leftActuator_sequence& s);

  // rightActuator
  //
  typedef ::actuator_transmission rightActuator_type;
  typedef ::xsd::cxx::tree::sequence< rightActuator_type > rightActuator_sequence;
  typedef rightActuator_sequence::iterator rightActuator_iterator;
  typedef rightActuator_sequence::const_iterator rightActuator_const_iterator;
  typedef ::xsd::cxx::tree::traits< rightActuator_type, char > rightActuator_traits;

  const rightActuator_sequence&
  rightActuator () const;

  rightActuator_sequence&
  rightActuator ();

  void
  rightActuator (const rightActuator_sequence& s);

  // flexJoint
  //
  typedef ::actuator_transmission flexJoint_type;
  typedef ::xsd::cxx::tree::sequence< flexJoint_type > flexJoint_sequence;
  typedef flexJoint_sequence::iterator flexJoint_iterator;
  typedef flexJoint_sequence::const_iterator flexJoint_const_iterator;
  typedef ::xsd::cxx::tree::traits< flexJoint_type, char > flexJoint_traits;

  const flexJoint_sequence&
  flexJoint () const;

  flexJoint_sequence&
  flexJoint ();

  void
  flexJoint (const flexJoint_sequence& s);

  // rollJoint
  //
  typedef ::actuator_transmission rollJoint_type;
  typedef ::xsd::cxx::tree::sequence< rollJoint_type > rollJoint_sequence;
  typedef rollJoint_sequence::iterator rollJoint_iterator;
  typedef rollJoint_sequence::const_iterator rollJoint_const_iterator;
  typedef ::xsd::cxx::tree::traits< rollJoint_type, char > rollJoint_traits;

  const rollJoint_sequence&
  rollJoint () const;

  rollJoint_sequence&
  rollJoint ();

  void
  rollJoint (const rollJoint_sequence& s);

  // gap_joint
  //
  typedef ::gap_joint_transmission gap_joint_type;
  typedef ::xsd::cxx::tree::sequence< gap_joint_type > gap_joint_sequence;
  typedef gap_joint_sequence::iterator gap_joint_iterator;
  typedef gap_joint_sequence::const_iterator gap_joint_const_iterator;
  typedef ::xsd::cxx::tree::traits< gap_joint_type, char > gap_joint_traits;

  const gap_joint_sequence&
  gap_joint () const;

  gap_joint_sequence&
  gap_joint ();

  void
  gap_joint (const gap_joint_sequence& s);

  // passive_joint
  //
  typedef ::passive_joint_transmission passive_joint_type;
  typedef ::xsd::cxx::tree::sequence< passive_joint_type > passive_joint_sequence;
  typedef passive_joint_sequence::iterator passive_joint_iterator;
  typedef passive_joint_sequence::const_iterator passive_joint_const_iterator;
  typedef ::xsd::cxx::tree::traits< passive_joint_type, char > passive_joint_traits;

  const passive_joint_sequence&
  passive_joint () const;

  passive_joint_sequence&
  passive_joint ();

  void
  passive_joint (const passive_joint_sequence& s);

  // use_simulated_gripper_joint
  //
  typedef ::use_simulated_gripper_joint use_simulated_gripper_joint_type;
  typedef ::xsd::cxx::tree::sequence< use_simulated_gripper_joint_type > use_simulated_gripper_joint_sequence;
  typedef use_simulated_gripper_joint_sequence::iterator use_simulated_gripper_joint_iterator;
  typedef use_simulated_gripper_joint_sequence::const_iterator use_simulated_gripper_joint_const_iterator;
  typedef ::xsd::cxx::tree::traits< use_simulated_gripper_joint_type, char > use_simulated_gripper_joint_traits;

  const use_simulated_gripper_joint_sequence&
  use_simulated_gripper_joint () const;

  use_simulated_gripper_joint_sequence&
  use_simulated_gripper_joint ();

  void
  use_simulated_gripper_joint (const use_simulated_gripper_joint_sequence& s);

  // mechanicalReduction
  //
  typedef ::xml_schema::double_ mechanicalReduction_type;
  typedef ::xsd::cxx::tree::sequence< mechanicalReduction_type > mechanicalReduction_sequence;
  typedef mechanicalReduction_sequence::iterator mechanicalReduction_iterator;
  typedef mechanicalReduction_sequence::const_iterator mechanicalReduction_const_iterator;
  typedef ::xsd::cxx::tree::traits< mechanicalReduction_type, char, ::xsd::cxx::tree::schema_type::double_ > mechanicalReduction_traits;

  const mechanicalReduction_sequence&
  mechanicalReduction () const;

  mechanicalReduction_sequence&
  mechanicalReduction ();

  void
  mechanicalReduction (const mechanicalReduction_sequence& s);

  // actuator
  //
  typedef ::name actuator_type;
  typedef ::xsd::cxx::tree::sequence< actuator_type > actuator_sequence;
  typedef actuator_sequence::iterator actuator_iterator;
  typedef actuator_sequence::const_iterator actuator_const_iterator;
  typedef ::xsd::cxx::tree::traits< actuator_type, char > actuator_traits;

  const actuator_sequence&
  actuator () const;

  actuator_sequence&
  actuator ();

  void
  actuator (const actuator_sequence& s);

  // joint
  //
  typedef ::name joint_type;
  typedef ::xsd::cxx::tree::sequence< joint_type > joint_sequence;
  typedef joint_sequence::iterator joint_iterator;
  typedef joint_sequence::const_iterator joint_const_iterator;
  typedef ::xsd::cxx::tree::traits< joint_type, char > joint_traits;

  const joint_sequence&
  joint () const;

  joint_sequence&
  joint ();

  void
  joint (const joint_sequence& s);

  // name
  //
  typedef ::xml_schema::string name_type;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_type&
  name () const;

  name_type&
  name ();

  void
  name (const name_type& x);

  void
  name (::std::auto_ptr< name_type > p);

  // type
  //
  typedef ::xml_schema::string type_type;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_type&
  type () const;

  type_type&
  type ();

  void
  type (const type_type& x);

  void
  type (::std::auto_ptr< type_type > p);

  // Constructors.
  //
  transmission (const name_type&,
                const type_type&);

  transmission (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  transmission (const transmission& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  virtual transmission*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  transmission&
  operator= (const transmission& x);

  virtual 
  ~transmission ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  leftActuator_sequence leftActuator_;
  rightActuator_sequence rightActuator_;
  flexJoint_sequence flexJoint_;
  rollJoint_sequence rollJoint_;
  gap_joint_sequence gap_joint_;
  passive_joint_sequence passive_joint_;
  use_simulated_gripper_joint_sequence use_simulated_gripper_joint_;
  mechanicalReduction_sequence mechanicalReduction_;
  actuator_sequence actuator_;
  joint_sequence joint_;
  ::xsd::cxx::tree::one< name_type > name_;
  ::xsd::cxx::tree::one< type_type > type_;
};

class joint: public ::xml_schema::type
{
  public:
  // origin
  //
  typedef ::pose origin_type;
  typedef ::xsd::cxx::tree::optional< origin_type > origin_optional;
  typedef ::xsd::cxx::tree::traits< origin_type, char > origin_traits;

  const origin_optional&
  origin () const;

  origin_optional&
  origin ();

  void
  origin (const origin_type& x);

  void
  origin (const origin_optional& x);

  void
  origin (::std::auto_ptr< origin_type > p);

  // parent
  //
  typedef ::parent parent_type;
  typedef ::xsd::cxx::tree::traits< parent_type, char > parent_traits;

  const parent_type&
  parent () const;

  parent_type&
  parent ();

  void
  parent (const parent_type& x);

  void
  parent (::std::auto_ptr< parent_type > p);

  // child
  //
  typedef ::child child_type;
  typedef ::xsd::cxx::tree::traits< child_type, char > child_traits;

  const child_type&
  child () const;

  child_type&
  child ();

  void
  child (const child_type& x);

  void
  child (::std::auto_ptr< child_type > p);

  // axis
  //
  typedef ::axis axis_type;
  typedef ::xsd::cxx::tree::optional< axis_type > axis_optional;
  typedef ::xsd::cxx::tree::traits< axis_type, char > axis_traits;

  const axis_optional&
  axis () const;

  axis_optional&
  axis ();

  void
  axis (const axis_type& x);

  void
  axis (const axis_optional& x);

  void
  axis (::std::auto_ptr< axis_type > p);

  // calibration
  //
  typedef ::calibration calibration_type;
  typedef ::xsd::cxx::tree::optional< calibration_type > calibration_optional;
  typedef ::xsd::cxx::tree::traits< calibration_type, char > calibration_traits;

  const calibration_optional&
  calibration () const;

  calibration_optional&
  calibration ();

  void
  calibration (const calibration_type& x);

  void
  calibration (const calibration_optional& x);

  void
  calibration (::std::auto_ptr< calibration_type > p);

  // dynamics
  //
  typedef ::dynamics dynamics_type;
  typedef ::xsd::cxx::tree::optional< dynamics_type > dynamics_optional;
  typedef ::xsd::cxx::tree::traits< dynamics_type, char > dynamics_traits;

  const dynamics_optional&
  dynamics () const;

  dynamics_optional&
  dynamics ();

  void
  dynamics (const dynamics_type& x);

  void
  dynamics (const dynamics_optional& x);

  void
  dynamics (::std::auto_ptr< dynamics_type > p);

  // limit
  //
  typedef ::limit limit_type;
  typedef ::xsd::cxx::tree::optional< limit_type > limit_optional;
  typedef ::xsd::cxx::tree::traits< limit_type, char > limit_traits;

  const limit_optional&
  limit () const;

  limit_optional&
  limit ();

  void
  limit (const limit_type& x);

  void
  limit (const limit_optional& x);

  void
  limit (::std::auto_ptr< limit_type > p);

  // safety_controller
  //
  typedef ::safety_controller safety_controller_type;
  typedef ::xsd::cxx::tree::optional< safety_controller_type > safety_controller_optional;
  typedef ::xsd::cxx::tree::traits< safety_controller_type, char > safety_controller_traits;

  const safety_controller_optional&
  safety_controller () const;

  safety_controller_optional&
  safety_controller ();

  void
  safety_controller (const safety_controller_type& x);

  void
  safety_controller (const safety_controller_optional& x);

  void
  safety_controller (::std::auto_ptr< safety_controller_type > p);

  // mimic
  //
  typedef ::mimic mimic_type;
  typedef ::xsd::cxx::tree::optional< mimic_type > mimic_optional;
  typedef ::xsd::cxx::tree::traits< mimic_type, char > mimic_traits;

  const mimic_optional&
  mimic () const;

  mimic_optional&
  mimic ();

  void
  mimic (const mimic_type& x);

  void
  mimic (const mimic_optional& x);

  void
  mimic (::std::auto_ptr< mimic_type > p);

  // name
  //
  typedef ::xml_schema::string name_type;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_type&
  name () const;

  name_type&
  name ();

  void
  name (const name_type& x);

  void
  name (::std::auto_ptr< name_type > p);

  // type
  //
  typedef ::xml_schema::string type_type;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_type&
  type () const;

  type_type&
  type ();

  void
  type (const type_type& x);

  void
  type (::std::auto_ptr< type_type > p);

  // Constructors.
  //
  joint (const parent_type&,
         const child_type&,
         const name_type&,
         const type_type&);

  joint (::std::auto_ptr< parent_type >,
         ::std::auto_ptr< child_type >,
         const name_type&,
         const type_type&);

  joint (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  joint (const joint& x,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  virtual joint*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  joint&
  operator= (const joint& x);

  virtual 
  ~joint ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  origin_optional origin_;
  ::xsd::cxx::tree::one< parent_type > parent_;
  ::xsd::cxx::tree::one< child_type > child_;
  axis_optional axis_;
  calibration_optional calibration_;
  dynamics_optional dynamics_;
  limit_optional limit_;
  safety_controller_optional safety_controller_;
  mimic_optional mimic_;
  ::xsd::cxx::tree::one< name_type > name_;
  ::xsd::cxx::tree::one< type_type > type_;
};

class Debug: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::boolean, char, ::xml_schema::simple_type >
{
  public:
  // Constructors.
  //
  Debug (const ::xml_schema::boolean&);

  Debug (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  Debug (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  Debug (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  Debug (const Debug& x,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  virtual Debug*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~Debug ();
};

class CrpiType: public ::xml_schema::string
{
  public:
  // Constructors.
  //
  CrpiType ();

  CrpiType (const char*);

  CrpiType (const ::std::string&);

  CrpiType (const ::xml_schema::string&);

  CrpiType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  CrpiType (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  CrpiType (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  CrpiType (const CrpiType& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual CrpiType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~CrpiType ();
};

class TCP_IP: public ::xml_schema::type
{
  public:
  // Address
  //
  typedef ::xml_schema::string Address_type;
  typedef ::xsd::cxx::tree::traits< Address_type, char > Address_traits;

  const Address_type&
  Address () const;

  Address_type&
  Address ();

  void
  Address (const Address_type& x);

  void
  Address (::std::auto_ptr< Address_type > p);

  // Port
  //
  typedef ::xml_schema::int_ Port_type;
  typedef ::xsd::cxx::tree::traits< Port_type, char > Port_traits;

  const Port_type&
  Port () const;

  Port_type&
  Port ();

  void
  Port (const Port_type& x);

  // Client
  //
  typedef ::xml_schema::boolean Client_type;
  typedef ::xsd::cxx::tree::traits< Client_type, char > Client_traits;

  const Client_type&
  Client () const;

  Client_type&
  Client ();

  void
  Client (const Client_type& x);

  // Constructors.
  //
  TCP_IP (const Address_type&,
          const Port_type&,
          const Client_type&);

  TCP_IP (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  TCP_IP (const TCP_IP& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  virtual TCP_IP*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  TCP_IP&
  operator= (const TCP_IP& x);

  virtual 
  ~TCP_IP ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< Address_type > Address_;
  ::xsd::cxx::tree::one< Port_type > Port_;
  ::xsd::cxx::tree::one< Client_type > Client_;
};

class ComType: public ::xml_schema::type
{
  public:
  // Val
  //
  typedef ::xml_schema::string Val_type;
  typedef ::xsd::cxx::tree::traits< Val_type, char > Val_traits;

  const Val_type&
  Val () const;

  Val_type&
  Val ();

  void
  Val (const Val_type& x);

  void
  Val (::std::auto_ptr< Val_type > p);

  // Constructors.
  //
  ComType (const Val_type&);

  ComType (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  ComType (const ComType& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  virtual ComType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  ComType&
  operator= (const ComType& x);

  virtual 
  ~ComType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< Val_type > Val_;
};

class CRCL_Robot: public ::xml_schema::type
{
  public:
  // Status_Request_Period
  //
  typedef ::xml_schema::double_ Status_Request_Period_type;
  typedef ::xsd::cxx::tree::optional< Status_Request_Period_type > Status_Request_Period_optional;
  typedef ::xsd::cxx::tree::traits< Status_Request_Period_type, char, ::xsd::cxx::tree::schema_type::double_ > Status_Request_Period_traits;

  const Status_Request_Period_optional&
  Status_Request_Period () const;

  Status_Request_Period_optional&
  Status_Request_Period ();

  void
  Status_Request_Period (const Status_Request_Period_type& x);

  void
  Status_Request_Period (const Status_Request_Period_optional& x);

  // Command_Schema
  //
  typedef ::xml_schema::string Command_Schema_type;
  typedef ::xsd::cxx::tree::optional< Command_Schema_type > Command_Schema_optional;
  typedef ::xsd::cxx::tree::traits< Command_Schema_type, char > Command_Schema_traits;

  const Command_Schema_optional&
  Command_Schema () const;

  Command_Schema_optional&
  Command_Schema ();

  void
  Command_Schema (const Command_Schema_type& x);

  void
  Command_Schema (const Command_Schema_optional& x);

  void
  Command_Schema (::std::auto_ptr< Command_Schema_type > p);

  // Status_Schema
  //
  typedef ::xml_schema::string Status_Schema_type;
  typedef ::xsd::cxx::tree::optional< Status_Schema_type > Status_Schema_optional;
  typedef ::xsd::cxx::tree::traits< Status_Schema_type, char > Status_Schema_traits;

  const Status_Schema_optional&
  Status_Schema () const;

  Status_Schema_optional&
  Status_Schema ();

  void
  Status_Schema (const Status_Schema_type& x);

  void
  Status_Schema (const Status_Schema_optional& x);

  void
  Status_Schema (::std::auto_ptr< Status_Schema_type > p);

  // Constructors.
  //
  CRCL_Robot ();

  CRCL_Robot (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  CRCL_Robot (const CRCL_Robot& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual CRCL_Robot*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  CRCL_Robot&
  operator= (const CRCL_Robot& x);

  virtual 
  ~CRCL_Robot ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Status_Request_Period_optional Status_Request_Period_;
  Command_Schema_optional Command_Schema_;
  Status_Schema_optional Status_Schema_;
};

class Mounting: public ::xml_schema::type
{
  public:
  // X
  //
  typedef ::xml_schema::decimal X_type;
  typedef ::xsd::cxx::tree::traits< X_type, char, ::xsd::cxx::tree::schema_type::decimal > X_traits;

  const X_type&
  X () const;

  X_type&
  X ();

  void
  X (const X_type& x);

  // Y
  //
  typedef ::xml_schema::decimal Y_type;
  typedef ::xsd::cxx::tree::traits< Y_type, char, ::xsd::cxx::tree::schema_type::decimal > Y_traits;

  const Y_type&
  Y () const;

  Y_type&
  Y ();

  void
  Y (const Y_type& x);

  // Z
  //
  typedef ::xml_schema::decimal Z_type;
  typedef ::xsd::cxx::tree::traits< Z_type, char, ::xsd::cxx::tree::schema_type::decimal > Z_traits;

  const Z_type&
  Z () const;

  Z_type&
  Z ();

  void
  Z (const Z_type& x);

  // XR
  //
  typedef ::xml_schema::decimal XR_type;
  typedef ::xsd::cxx::tree::traits< XR_type, char, ::xsd::cxx::tree::schema_type::decimal > XR_traits;

  const XR_type&
  XR () const;

  XR_type&
  XR ();

  void
  XR (const XR_type& x);

  // YR
  //
  typedef ::xml_schema::decimal YR_type;
  typedef ::xsd::cxx::tree::traits< YR_type, char, ::xsd::cxx::tree::schema_type::decimal > YR_traits;

  const YR_type&
  YR () const;

  YR_type&
  YR ();

  void
  YR (const YR_type& x);

  // ZR
  //
  typedef ::xml_schema::decimal ZR_type;
  typedef ::xsd::cxx::tree::traits< ZR_type, char, ::xsd::cxx::tree::schema_type::decimal > ZR_traits;

  const ZR_type&
  ZR () const;

  ZR_type&
  ZR ();

  void
  ZR (const ZR_type& x);

  // Constructors.
  //
  Mounting (const X_type&,
            const Y_type&,
            const Z_type&,
            const XR_type&,
            const YR_type&,
            const ZR_type&);

  Mounting (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  Mounting (const Mounting& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual Mounting*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  Mounting&
  operator= (const Mounting& x);

  virtual 
  ~Mounting ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< X_type > X_;
  ::xsd::cxx::tree::one< Y_type > Y_;
  ::xsd::cxx::tree::one< Z_type > Z_;
  ::xsd::cxx::tree::one< XR_type > XR_;
  ::xsd::cxx::tree::one< YR_type > YR_;
  ::xsd::cxx::tree::one< ZR_type > ZR_;
};

class ToWorld: public ::xml_schema::type
{
  public:
  // X
  //
  typedef ::xml_schema::decimal X_type;
  typedef ::xsd::cxx::tree::traits< X_type, char, ::xsd::cxx::tree::schema_type::decimal > X_traits;

  const X_type&
  X () const;

  X_type&
  X ();

  void
  X (const X_type& x);

  // Y
  //
  typedef ::xml_schema::decimal Y_type;
  typedef ::xsd::cxx::tree::traits< Y_type, char, ::xsd::cxx::tree::schema_type::decimal > Y_traits;

  const Y_type&
  Y () const;

  Y_type&
  Y ();

  void
  Y (const Y_type& x);

  // Z
  //
  typedef ::xml_schema::decimal Z_type;
  typedef ::xsd::cxx::tree::traits< Z_type, char, ::xsd::cxx::tree::schema_type::decimal > Z_traits;

  const Z_type&
  Z () const;

  Z_type&
  Z ();

  void
  Z (const Z_type& x);

  // XR
  //
  typedef ::xml_schema::decimal XR_type;
  typedef ::xsd::cxx::tree::traits< XR_type, char, ::xsd::cxx::tree::schema_type::decimal > XR_traits;

  const XR_type&
  XR () const;

  XR_type&
  XR ();

  void
  XR (const XR_type& x);

  // YR
  //
  typedef ::xml_schema::decimal YR_type;
  typedef ::xsd::cxx::tree::traits< YR_type, char, ::xsd::cxx::tree::schema_type::decimal > YR_traits;

  const YR_type&
  YR () const;

  YR_type&
  YR ();

  void
  YR (const YR_type& x);

  // ZR
  //
  typedef ::xml_schema::decimal ZR_type;
  typedef ::xsd::cxx::tree::traits< ZR_type, char, ::xsd::cxx::tree::schema_type::decimal > ZR_traits;

  const ZR_type&
  ZR () const;

  ZR_type&
  ZR ();

  void
  ZR (const ZR_type& x);

  // M00
  //
  typedef ::xml_schema::decimal M00_type;
  typedef ::xsd::cxx::tree::optional< M00_type > M00_optional;
  typedef ::xsd::cxx::tree::traits< M00_type, char, ::xsd::cxx::tree::schema_type::decimal > M00_traits;

  const M00_optional&
  M00 () const;

  M00_optional&
  M00 ();

  void
  M00 (const M00_type& x);

  void
  M00 (const M00_optional& x);

  // M01
  //
  typedef ::xml_schema::decimal M01_type;
  typedef ::xsd::cxx::tree::optional< M01_type > M01_optional;
  typedef ::xsd::cxx::tree::traits< M01_type, char, ::xsd::cxx::tree::schema_type::decimal > M01_traits;

  const M01_optional&
  M01 () const;

  M01_optional&
  M01 ();

  void
  M01 (const M01_type& x);

  void
  M01 (const M01_optional& x);

  // M02
  //
  typedef ::xml_schema::decimal M02_type;
  typedef ::xsd::cxx::tree::optional< M02_type > M02_optional;
  typedef ::xsd::cxx::tree::traits< M02_type, char, ::xsd::cxx::tree::schema_type::decimal > M02_traits;

  const M02_optional&
  M02 () const;

  M02_optional&
  M02 ();

  void
  M02 (const M02_type& x);

  void
  M02 (const M02_optional& x);

  // M03
  //
  typedef ::xml_schema::decimal M03_type;
  typedef ::xsd::cxx::tree::optional< M03_type > M03_optional;
  typedef ::xsd::cxx::tree::traits< M03_type, char, ::xsd::cxx::tree::schema_type::decimal > M03_traits;

  const M03_optional&
  M03 () const;

  M03_optional&
  M03 ();

  void
  M03 (const M03_type& x);

  void
  M03 (const M03_optional& x);

  // M10
  //
  typedef ::xml_schema::decimal M10_type;
  typedef ::xsd::cxx::tree::optional< M10_type > M10_optional;
  typedef ::xsd::cxx::tree::traits< M10_type, char, ::xsd::cxx::tree::schema_type::decimal > M10_traits;

  const M10_optional&
  M10 () const;

  M10_optional&
  M10 ();

  void
  M10 (const M10_type& x);

  void
  M10 (const M10_optional& x);

  // M11
  //
  typedef ::xml_schema::decimal M11_type;
  typedef ::xsd::cxx::tree::optional< M11_type > M11_optional;
  typedef ::xsd::cxx::tree::traits< M11_type, char, ::xsd::cxx::tree::schema_type::decimal > M11_traits;

  const M11_optional&
  M11 () const;

  M11_optional&
  M11 ();

  void
  M11 (const M11_type& x);

  void
  M11 (const M11_optional& x);

  // M12
  //
  typedef ::xml_schema::decimal M12_type;
  typedef ::xsd::cxx::tree::optional< M12_type > M12_optional;
  typedef ::xsd::cxx::tree::traits< M12_type, char, ::xsd::cxx::tree::schema_type::decimal > M12_traits;

  const M12_optional&
  M12 () const;

  M12_optional&
  M12 ();

  void
  M12 (const M12_type& x);

  void
  M12 (const M12_optional& x);

  // M13
  //
  typedef ::xml_schema::decimal M13_type;
  typedef ::xsd::cxx::tree::optional< M13_type > M13_optional;
  typedef ::xsd::cxx::tree::traits< M13_type, char, ::xsd::cxx::tree::schema_type::decimal > M13_traits;

  const M13_optional&
  M13 () const;

  M13_optional&
  M13 ();

  void
  M13 (const M13_type& x);

  void
  M13 (const M13_optional& x);

  // M20
  //
  typedef ::xml_schema::decimal M20_type;
  typedef ::xsd::cxx::tree::optional< M20_type > M20_optional;
  typedef ::xsd::cxx::tree::traits< M20_type, char, ::xsd::cxx::tree::schema_type::decimal > M20_traits;

  const M20_optional&
  M20 () const;

  M20_optional&
  M20 ();

  void
  M20 (const M20_type& x);

  void
  M20 (const M20_optional& x);

  // M21
  //
  typedef ::xml_schema::decimal M21_type;
  typedef ::xsd::cxx::tree::optional< M21_type > M21_optional;
  typedef ::xsd::cxx::tree::traits< M21_type, char, ::xsd::cxx::tree::schema_type::decimal > M21_traits;

  const M21_optional&
  M21 () const;

  M21_optional&
  M21 ();

  void
  M21 (const M21_type& x);

  void
  M21 (const M21_optional& x);

  // M22
  //
  typedef ::xml_schema::decimal M22_type;
  typedef ::xsd::cxx::tree::optional< M22_type > M22_optional;
  typedef ::xsd::cxx::tree::traits< M22_type, char, ::xsd::cxx::tree::schema_type::decimal > M22_traits;

  const M22_optional&
  M22 () const;

  M22_optional&
  M22 ();

  void
  M22 (const M22_type& x);

  void
  M22 (const M22_optional& x);

  // M23
  //
  typedef ::xml_schema::decimal M23_type;
  typedef ::xsd::cxx::tree::optional< M23_type > M23_optional;
  typedef ::xsd::cxx::tree::traits< M23_type, char, ::xsd::cxx::tree::schema_type::decimal > M23_traits;

  const M23_optional&
  M23 () const;

  M23_optional&
  M23 ();

  void
  M23 (const M23_type& x);

  void
  M23 (const M23_optional& x);

  // M30
  //
  typedef ::xml_schema::decimal M30_type;
  typedef ::xsd::cxx::tree::optional< M30_type > M30_optional;
  typedef ::xsd::cxx::tree::traits< M30_type, char, ::xsd::cxx::tree::schema_type::decimal > M30_traits;

  const M30_optional&
  M30 () const;

  M30_optional&
  M30 ();

  void
  M30 (const M30_type& x);

  void
  M30 (const M30_optional& x);

  // M31
  //
  typedef ::xml_schema::decimal M31_type;
  typedef ::xsd::cxx::tree::optional< M31_type > M31_optional;
  typedef ::xsd::cxx::tree::traits< M31_type, char, ::xsd::cxx::tree::schema_type::decimal > M31_traits;

  const M31_optional&
  M31 () const;

  M31_optional&
  M31 ();

  void
  M31 (const M31_type& x);

  void
  M31 (const M31_optional& x);

  // M32
  //
  typedef ::xml_schema::decimal M32_type;
  typedef ::xsd::cxx::tree::optional< M32_type > M32_optional;
  typedef ::xsd::cxx::tree::traits< M32_type, char, ::xsd::cxx::tree::schema_type::decimal > M32_traits;

  const M32_optional&
  M32 () const;

  M32_optional&
  M32 ();

  void
  M32 (const M32_type& x);

  void
  M32 (const M32_optional& x);

  // M33
  //
  typedef ::xml_schema::decimal M33_type;
  typedef ::xsd::cxx::tree::optional< M33_type > M33_optional;
  typedef ::xsd::cxx::tree::traits< M33_type, char, ::xsd::cxx::tree::schema_type::decimal > M33_traits;

  const M33_optional&
  M33 () const;

  M33_optional&
  M33 ();

  void
  M33 (const M33_type& x);

  void
  M33 (const M33_optional& x);

  // Constructors.
  //
  ToWorld (const X_type&,
           const Y_type&,
           const Z_type&,
           const XR_type&,
           const YR_type&,
           const ZR_type&);

  ToWorld (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  ToWorld (const ToWorld& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  virtual ToWorld*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  ToWorld&
  operator= (const ToWorld& x);

  virtual 
  ~ToWorld ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< X_type > X_;
  ::xsd::cxx::tree::one< Y_type > Y_;
  ::xsd::cxx::tree::one< Z_type > Z_;
  ::xsd::cxx::tree::one< XR_type > XR_;
  ::xsd::cxx::tree::one< YR_type > YR_;
  ::xsd::cxx::tree::one< ZR_type > ZR_;
  M00_optional M00_;
  M01_optional M01_;
  M02_optional M02_;
  M03_optional M03_;
  M10_optional M10_;
  M11_optional M11_;
  M12_optional M12_;
  M13_optional M13_;
  M20_optional M20_;
  M21_optional M21_;
  M22_optional M22_;
  M23_optional M23_;
  M30_optional M30_;
  M31_optional M31_;
  M32_optional M32_;
  M33_optional M33_;
};

class Tool: public ::xml_schema::type
{
  public:
  // ID
  //
  typedef ::xml_schema::int_ ID_type;
  typedef ::xsd::cxx::tree::traits< ID_type, char > ID_traits;

  const ID_type&
  ID () const;

  ID_type&
  ID ();

  void
  ID (const ID_type& x);

  // Name
  //
  typedef ::xml_schema::string Name_type;
  typedef ::xsd::cxx::tree::traits< Name_type, char > Name_traits;

  const Name_type&
  Name () const;

  Name_type&
  Name ();

  void
  Name (const Name_type& x);

  void
  Name (::std::auto_ptr< Name_type > p);

  // X
  //
  typedef ::xml_schema::decimal X_type;
  typedef ::xsd::cxx::tree::traits< X_type, char, ::xsd::cxx::tree::schema_type::decimal > X_traits;

  const X_type&
  X () const;

  X_type&
  X ();

  void
  X (const X_type& x);

  // Y
  //
  typedef ::xml_schema::decimal Y_type;
  typedef ::xsd::cxx::tree::traits< Y_type, char, ::xsd::cxx::tree::schema_type::decimal > Y_traits;

  const Y_type&
  Y () const;

  Y_type&
  Y ();

  void
  Y (const Y_type& x);

  // Z
  //
  typedef ::xml_schema::decimal Z_type;
  typedef ::xsd::cxx::tree::traits< Z_type, char, ::xsd::cxx::tree::schema_type::decimal > Z_traits;

  const Z_type&
  Z () const;

  Z_type&
  Z ();

  void
  Z (const Z_type& x);

  // XR
  //
  typedef ::xml_schema::decimal XR_type;
  typedef ::xsd::cxx::tree::traits< XR_type, char, ::xsd::cxx::tree::schema_type::decimal > XR_traits;

  const XR_type&
  XR () const;

  XR_type&
  XR ();

  void
  XR (const XR_type& x);

  // YR
  //
  typedef ::xml_schema::decimal YR_type;
  typedef ::xsd::cxx::tree::traits< YR_type, char, ::xsd::cxx::tree::schema_type::decimal > YR_traits;

  const YR_type&
  YR () const;

  YR_type&
  YR ();

  void
  YR (const YR_type& x);

  // ZR
  //
  typedef ::xml_schema::decimal ZR_type;
  typedef ::xsd::cxx::tree::traits< ZR_type, char, ::xsd::cxx::tree::schema_type::decimal > ZR_traits;

  const ZR_type&
  ZR () const;

  ZR_type&
  ZR ();

  void
  ZR (const ZR_type& x);

  // Mass
  //
  typedef ::xml_schema::decimal Mass_type;
  typedef ::xsd::cxx::tree::optional< Mass_type > Mass_optional;
  typedef ::xsd::cxx::tree::traits< Mass_type, char, ::xsd::cxx::tree::schema_type::decimal > Mass_traits;

  const Mass_optional&
  Mass () const;

  Mass_optional&
  Mass ();

  void
  Mass (const Mass_type& x);

  void
  Mass (const Mass_optional& x);

  // MX
  //
  typedef ::xml_schema::decimal MX_type;
  typedef ::xsd::cxx::tree::optional< MX_type > MX_optional;
  typedef ::xsd::cxx::tree::traits< MX_type, char, ::xsd::cxx::tree::schema_type::decimal > MX_traits;

  const MX_optional&
  MX () const;

  MX_optional&
  MX ();

  void
  MX (const MX_type& x);

  void
  MX (const MX_optional& x);

  // MY
  //
  typedef ::xml_schema::decimal MY_type;
  typedef ::xsd::cxx::tree::optional< MY_type > MY_optional;
  typedef ::xsd::cxx::tree::traits< MY_type, char, ::xsd::cxx::tree::schema_type::decimal > MY_traits;

  const MY_optional&
  MY () const;

  MY_optional&
  MY ();

  void
  MY (const MY_type& x);

  void
  MY (const MY_optional& x);

  // MZ
  //
  typedef ::xml_schema::decimal MZ_type;
  typedef ::xsd::cxx::tree::optional< MZ_type > MZ_optional;
  typedef ::xsd::cxx::tree::traits< MZ_type, char, ::xsd::cxx::tree::schema_type::decimal > MZ_traits;

  const MZ_optional&
  MZ () const;

  MZ_optional&
  MZ ();

  void
  MZ (const MZ_type& x);

  void
  MZ (const MZ_optional& x);

  // Constructors.
  //
  Tool (const ID_type&,
        const Name_type&,
        const X_type&,
        const Y_type&,
        const Z_type&,
        const XR_type&,
        const YR_type&,
        const ZR_type&);

  Tool (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  Tool (const Tool& x,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  virtual Tool*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  Tool&
  operator= (const Tool& x);

  virtual 
  ~Tool ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< ID_type > ID_;
  ::xsd::cxx::tree::one< Name_type > Name_;
  ::xsd::cxx::tree::one< X_type > X_;
  ::xsd::cxx::tree::one< Y_type > Y_;
  ::xsd::cxx::tree::one< Z_type > Z_;
  ::xsd::cxx::tree::one< XR_type > XR_;
  ::xsd::cxx::tree::one< YR_type > YR_;
  ::xsd::cxx::tree::one< ZR_type > ZR_;
  Mass_optional Mass_;
  MX_optional MX_;
  MY_optional MY_;
  MZ_optional MZ_;
};

class use_simulated_gripper_joint: public ::xml_schema::type
{
  public:
  // Constructors.
  //
  use_simulated_gripper_joint ();

  use_simulated_gripper_joint (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

  use_simulated_gripper_joint (const ::xercesc::DOMAttr& a,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

  use_simulated_gripper_joint (const ::std::string& s,
                               const ::xercesc::DOMElement* e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

  use_simulated_gripper_joint (const use_simulated_gripper_joint& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

  virtual use_simulated_gripper_joint*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~use_simulated_gripper_joint ();
};

class robot: public ::xml_schema::type
{
  public:
  // Debug
  //
  typedef ::Debug Debug_type;
  typedef ::xsd::cxx::tree::optional< Debug_type > Debug_optional;
  typedef ::xsd::cxx::tree::traits< Debug_type, char > Debug_traits;

  const Debug_optional&
  Debug () const;

  Debug_optional&
  Debug ();

  void
  Debug (const Debug_type& x);

  void
  Debug (const Debug_optional& x);

  void
  Debug (::std::auto_ptr< Debug_type > p);

  // CrpiType
  //
  typedef ::CrpiType CrpiType_type;
  typedef ::xsd::cxx::tree::optional< CrpiType_type > CrpiType_optional;
  typedef ::xsd::cxx::tree::traits< CrpiType_type, char > CrpiType_traits;

  const CrpiType_optional&
  CrpiType () const;

  CrpiType_optional&
  CrpiType ();

  void
  CrpiType (const CrpiType_type& x);

  void
  CrpiType (const CrpiType_optional& x);

  void
  CrpiType (::std::auto_ptr< CrpiType_type > p);

  // TCP_IP
  //
  typedef ::TCP_IP TCP_IP_type;
  typedef ::xsd::cxx::tree::traits< TCP_IP_type, char > TCP_IP_traits;

  const TCP_IP_type&
  TCP_IP () const;

  TCP_IP_type&
  TCP_IP ();

  void
  TCP_IP (const TCP_IP_type& x);

  void
  TCP_IP (::std::auto_ptr< TCP_IP_type > p);

  // ComType
  //
  typedef ::ComType ComType_type;
  typedef ::xsd::cxx::tree::optional< ComType_type > ComType_optional;
  typedef ::xsd::cxx::tree::traits< ComType_type, char > ComType_traits;

  const ComType_optional&
  ComType () const;

  ComType_optional&
  ComType ();

  void
  ComType (const ComType_type& x);

  void
  ComType (const ComType_optional& x);

  void
  ComType (::std::auto_ptr< ComType_type > p);

  // CRCL_Robot
  //
  typedef ::CRCL_Robot CRCL_Robot_type;
  typedef ::xsd::cxx::tree::optional< CRCL_Robot_type > CRCL_Robot_optional;
  typedef ::xsd::cxx::tree::traits< CRCL_Robot_type, char > CRCL_Robot_traits;

  const CRCL_Robot_optional&
  CRCL_Robot () const;

  CRCL_Robot_optional&
  CRCL_Robot ();

  void
  CRCL_Robot (const CRCL_Robot_type& x);

  void
  CRCL_Robot (const CRCL_Robot_optional& x);

  void
  CRCL_Robot (::std::auto_ptr< CRCL_Robot_type > p);

  // Mounting
  //
  typedef ::Mounting Mounting_type;
  typedef ::xsd::cxx::tree::optional< Mounting_type > Mounting_optional;
  typedef ::xsd::cxx::tree::traits< Mounting_type, char > Mounting_traits;

  const Mounting_optional&
  Mounting () const;

  Mounting_optional&
  Mounting ();

  void
  Mounting (const Mounting_type& x);

  void
  Mounting (const Mounting_optional& x);

  void
  Mounting (::std::auto_ptr< Mounting_type > p);

  // ToWorld
  //
  typedef ::ToWorld ToWorld_type;
  typedef ::xsd::cxx::tree::optional< ToWorld_type > ToWorld_optional;
  typedef ::xsd::cxx::tree::traits< ToWorld_type, char > ToWorld_traits;

  const ToWorld_optional&
  ToWorld () const;

  ToWorld_optional&
  ToWorld ();

  void
  ToWorld (const ToWorld_type& x);

  void
  ToWorld (const ToWorld_optional& x);

  void
  ToWorld (::std::auto_ptr< ToWorld_type > p);

  // Tool
  //
  typedef ::Tool Tool_type;
  typedef ::xsd::cxx::tree::sequence< Tool_type > Tool_sequence;
  typedef Tool_sequence::iterator Tool_iterator;
  typedef Tool_sequence::const_iterator Tool_const_iterator;
  typedef ::xsd::cxx::tree::traits< Tool_type, char > Tool_traits;

  const Tool_sequence&
  Tool () const;

  Tool_sequence&
  Tool ();

  void
  Tool (const Tool_sequence& s);

  // link
  //
  typedef ::link link_type;
  typedef ::xsd::cxx::tree::sequence< link_type > link_sequence;
  typedef link_sequence::iterator link_iterator;
  typedef link_sequence::const_iterator link_const_iterator;
  typedef ::xsd::cxx::tree::traits< link_type, char > link_traits;

  const link_sequence&
  link () const;

  link_sequence&
  link ();

  void
  link (const link_sequence& s);

  // joint
  //
  typedef ::joint joint_type;
  typedef ::xsd::cxx::tree::sequence< joint_type > joint_sequence;
  typedef joint_sequence::iterator joint_iterator;
  typedef joint_sequence::const_iterator joint_const_iterator;
  typedef ::xsd::cxx::tree::traits< joint_type, char > joint_traits;

  const joint_sequence&
  joint () const;

  joint_sequence&
  joint ();

  void
  joint (const joint_sequence& s);

  // name
  //
  typedef ::xml_schema::string name_type;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_type&
  name () const;

  name_type&
  name ();

  void
  name (const name_type& x);

  void
  name (::std::auto_ptr< name_type > p);

  // version
  //
  typedef ::xml_schema::string version_type;
  typedef ::xsd::cxx::tree::traits< version_type, char > version_traits;

  const version_type&
  version () const;

  version_type&
  version ();

  void
  version (const version_type& x);

  void
  version (::std::auto_ptr< version_type > p);

  static const version_type&
  version_default_value ();

  // Constructors.
  //
  robot (const TCP_IP_type&,
         const name_type&);

  robot (::std::auto_ptr< TCP_IP_type >,
         const name_type&);

  robot (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  robot (const robot& x,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  virtual robot*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  robot&
  operator= (const robot& x);

  virtual 
  ~robot ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Debug_optional Debug_;
  CrpiType_optional CrpiType_;
  ::xsd::cxx::tree::one< TCP_IP_type > TCP_IP_;
  ComType_optional ComType_;
  CRCL_Robot_optional CRCL_Robot_;
  Mounting_optional Mounting_;
  ToWorld_optional ToWorld_;
  Tool_sequence Tool_;
  link_sequence link_;
  joint_sequence joint_;
  ::xsd::cxx::tree::one< name_type > name_;
  ::xsd::cxx::tree::one< version_type > version_;
  static const version_type version_default_value_;
};

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

// Parse a URI or a local file.
//

::std::auto_ptr< ::robot >
robot_ (const ::std::string& uri,
        ::xml_schema::flags f = 0,
        const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::robot >
robot_ (const ::std::string& uri,
        ::xml_schema::error_handler& eh,
        ::xml_schema::flags f = 0,
        const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::robot >
robot_ (const ::std::string& uri,
        ::xercesc::DOMErrorHandler& eh,
        ::xml_schema::flags f = 0,
        const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse std::istream.
//

::std::auto_ptr< ::robot >
robot_ (::std::istream& is,
        ::xml_schema::flags f = 0,
        const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::robot >
robot_ (::std::istream& is,
        ::xml_schema::error_handler& eh,
        ::xml_schema::flags f = 0,
        const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::robot >
robot_ (::std::istream& is,
        ::xercesc::DOMErrorHandler& eh,
        ::xml_schema::flags f = 0,
        const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::robot >
robot_ (::std::istream& is,
        const ::std::string& id,
        ::xml_schema::flags f = 0,
        const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::robot >
robot_ (::std::istream& is,
        const ::std::string& id,
        ::xml_schema::error_handler& eh,
        ::xml_schema::flags f = 0,
        const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::robot >
robot_ (::std::istream& is,
        const ::std::string& id,
        ::xercesc::DOMErrorHandler& eh,
        ::xml_schema::flags f = 0,
        const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse xercesc::InputSource.
//

::std::auto_ptr< ::robot >
robot_ (::xercesc::InputSource& is,
        ::xml_schema::flags f = 0,
        const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::robot >
robot_ (::xercesc::InputSource& is,
        ::xml_schema::error_handler& eh,
        ::xml_schema::flags f = 0,
        const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::robot >
robot_ (::xercesc::InputSource& is,
        ::xercesc::DOMErrorHandler& eh,
        ::xml_schema::flags f = 0,
        const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse xercesc::DOMDocument.
//

::std::auto_ptr< ::robot >
robot_ (const ::xercesc::DOMDocument& d,
        ::xml_schema::flags f = 0,
        const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::robot >
robot_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
        ::xml_schema::flags f = 0,
        const ::xml_schema::properties& p = ::xml_schema::properties ());

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // CXX______SCHEMAS_URDF_CRPI_HXX
